<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bruin Catch (Unofficial)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* --- CSS Styles (No changes needed here, but kept for completeness) --- */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #ADD8E6; font-family: 'Press Start 2P', cursive; }
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
            touch-action: none;
            transition: background-color 1s ease;
        }
        .intro-text { font-size: 0.9em; color: #333; margin-bottom: 1rem; text-align: center; flex-shrink: 0; width: 100%; }
.game-container {
    border: 5px solid #2774AE;
    position: relative;
    overflow: hidden;
    width: 100%;
    max-width: 600px;
    /* Adjusted: Use max-height to prevent exceeding viewport */
    max-height: 100vh; /* Ensure it doesn't exceed viewport height */
    aspect-ratio: 3 / 4;
    border-radius: 15px;
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    background-color: #F2A900;
    cursor: grab;
    margin-top: 0;
    flex-shrink: 1;
    min-height: 0;
    outline: none;
}

/* Ensure the body doesn't cause additional scrolling */
html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #ADD8E6;
    font-family: 'Press Start 2P', cursive;
}

body {
    display: flex;
    flex-direction: column;
    justify-content: center; /* Center the game-container vertically */
    align-items: center;
    min-height: 100vh;
    padding: 1rem;
    box-sizing: border-box;
    touch-action: none;
    transition: background-color 1s ease;
    overflow: auto; /* Allow scrolling if absolutely necessary */
}

/* Responsive adjustments for game-container */
@media (max-width: 600px) {
    .game-container {
        max-height: 90vh; /* Slightly smaller to account for padding */
    }
}

@media (max-width: 450px) {
    .game-container {
        max-height: 85vh; /* Further reduce on very small screens */
    }
}
        canvas { display: block; width: 100%; height: 100%; visibility: hidden; background-color: transparent; }
/* Name Input Overlay */
#name-input-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.95);
    z-index: 30;
    display: flex;
    flex-direction: column;
    /* --- MODIFIED: Center content, reduce padding, keep overflow & box-sizing --- */
    justify-content: center; /* Center content vertically to fit all elements */
    padding-top: 15px; /* Further reduced space at the top */
    padding-bottom: 10px; /* Further reduced space at the bottom */
    padding-left: 15px;
    padding-right: 15px;
    box-sizing: border-box; /* Include padding in height calculation */
    overflow-y: auto;       /* Allow scrolling if needed, but aim to avoid it */
    /* --- End Modified --- */
    align-items: center; /* Keep items centered horizontally */
    text-align: center;
    color: #2774AE;
}
#name-input-overlay h2 {
    font-size: 1.2em; /* Slightly reduced */
    margin-bottom: 8px; /* Reduced margin */
    flex-shrink: 0; /* Added to prevent shrinking */
}
#name-input-overlay p {
    font-size: 0.75em; /* Slightly reduced */
    line-height: 1.3; /* Slightly tighter line height */
    margin-bottom: 4px; /* Reduced margin */
    max-width: 90%;
    flex-shrink: 0; /* Added to prevent shrinking */
}
#name-input-overlay .fullscreen-hint {
    font-size: 0.6em; /* Slightly reduced */
    color: #555;
    margin-top: 4px;
    margin-bottom: 8px; /* Reduced margin */
    flex-shrink: 0; /* Added to prevent shrinking */
}
#player-name-input {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.9em; /* Slightly reduced */
    padding: 6px; /* Reduced padding */
    margin-bottom: 8px; /* Reduced margin */
    border: 2px solid #2774AE;
    border-radius: 5px;
    text-align: center;
    width: 80%;
    max-width: 250px;
    flex-shrink: 0; /* Already added as per your comment */
}
#start-game-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.85em; /* Slightly reduced font-size */
    padding: 8px 18px; /* Reduced padding */
    background-color: #2774AE;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    flex-shrink: 0;
}
#start-game-button:hover {
    background-color: #1E5A8C;
}
#leaderboard-display {
    margin-top: 8px; /* Reduced margin */
    width: 90%;
    max-width: 350px;
    max-height: 100px; /* Further reduced max-height to fit better */
    overflow-y: auto; /* Keep leaderboard's own scroll */
    background: rgba(240, 240, 240, 0.8);
    border: 1px solid #ccc;
    padding: 4px 8px; /* Reduced padding */
    border-radius: 5px;
    font-size: 0.65em; /* Slightly reduced */
    box-sizing: border-box;
    flex-shrink: 0; /* Keep this - prevents shrinking */
}
#leaderboard-display h3 {
    margin: 0 0 4px 0; /* Reduced margin */
    font-size: 1em; /* Slightly reduced */
    text-align: center;
    flex-shrink: 0; /* Added */
}
#leaderboard-list {
    list-style: none;
    padding: 0;
    margin: 0;
    /* flex-shrink: 0; Might not be needed as parent handles scroll */
}
#leaderboard-list li {
    display: flex;
    justify-content: space-between;
    padding: 2px 0; /* Reduced padding */
    border-bottom: 1px dashed #ddd;
    flex-shrink: 0; /* Added */
}
#leaderboard-list li:last-child {
    border-bottom: none;
}
#leaderboard-list .rank {
    font-weight: bold;
    flex-basis: 10%;
    text-align: right;
    margin-right: 8px; /* Increased margin */
}
#leaderboard-list .name {
    flex-grow: 1;
    text-align: left;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: 8px; /* Increased margin */
}
#leaderboard-list .score {
    font-weight: bold;
    flex-basis: 20%;
    text-align: right;
    margin-right: 8px; /* Increased margin */
}
#leaderboard-list .level {
    flex-basis: 15%;
    text-align: right;
    color: #555;
}
/* Add near other #name-input-overlay styles */
.button-container {
    display: flex; /* Align buttons side-by-side */
    align-items: center; /* Vertically align items if heights differ */
    justify-content: center; /* Center the buttons */
    gap: 8px; /* Further reduced space between buttons */
    margin-bottom: 8px; /* Reduced space below buttons */
    flex-shrink: 0; /* Prevent shrinking */
}

#fullscreen-button {
    font-family: 'Press Start 2P', cursive; /* Match style */
    font-size: 1.1em; /* Slightly reduced */
    padding: 6px 8px; /* Reduced padding */
    background-color: #6c757d; /* Greyish color */
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    line-height: 1; /* Ensure icon centers vertically */
    display: none; /* Hidden by default (will be shown on mobile) */
}

#fullscreen-button:hover {
    background-color: #5a6268;
}

#sound-toggle-button {
    font-family: 'Press Start 2P', cursive; /* Match style */
    font-size: 1.1em; /* Slightly reduced */
    padding: 6px 8px; /* Reduced padding */
    background-color: #6c757d; /* Greyish color, similar to fullscreen */
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    line-height: 1; /* Ensure icon centers vertically */
    min-width: 40px; /* Ensure it has some width */
    text-align: center;
}

#sound-toggle-button:hover {
    background-color: #5a6268;
}

/* Achievements Button */
#achievements-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.85em; /* Slightly reduced font-size */
    padding: 6px 12px; /* Reduced padding */
    background-color: #FF8C00; /* Orange, like how-to-play-button */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin: 4px auto; /* Reduced margin */
    display: block;
}

#achievements-button:hover {
    background-color: #E07B00;
}

/* Achievements Modal */
#achievements-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.6);
    z-index: 100;
    display: none;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
}

#achievements-modal .modal-content {
    background-color: #fff;
    color: #333;
    padding: 25px;
    border-radius: 10px;
    max-width: 500px;
    width: 90%;
    text-align: left;
    font-size: 0.8em;
    line-height: 1.6;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    max-height: 80vh;
    overflow-y: auto;
}
        /* Progress Bar Styles */
.progress-bar {
    width: 100%;
    height: 10px;
    background-color: #ddd; /* Light grey background for the bar */
    border-radius: 5px;
    margin-top: 8px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background-color: #2774AE; /* Match the game's blue theme */
    border-radius: 5px;
    transition: width 0.3s ease; /* Smooth transition for progress updates */
}

.achievement-item.locked .progress-fill {
    background-color: #999; /* Greyed out for locked achievements */
}

.progress-text {
    font-size: 0.7em;
    color: #333;
    text-align: center;
    margin-top: 4px;
}

.achievement-item.locked .progress-text {
    color: #777; /* Lighter color for locked achievements */
}

#achievements-modal h2 {
    font-size: 1.3em;
    color: #2774AE;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
}

#achievements-list {
    margin-bottom: 20px;
}

.achievement-item {
    margin: 10px 0;
    padding: 10px;
    border-radius: 5px;
}

.achievement-item.unlocked {
    background-color: #E6F3FF;
}

.achievement-item.locked {
    background-color: #F0F0F0;
    opacity: 0.7;
}

.achievement-item span {
    color: #777;
    font-style: italic;
}

#close-achievements-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.9em;
    padding: 10px 20px;
    background-color: #2774AE;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin: 10px auto;
    display: block;
}

#close-achievements-button:hover {
    background-color: #1E5A8C;
}

/* Achievement Notification */
#achievement-notification {
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Press Start 2P', cursive;
    font-size: 1em;
    color: #FFD700;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 10px 20px;
    border-radius: 8px;
    z-index: 25;
    display: none;
    text-align: center;
    animation: fadeOutNotification 2s forwards;
}

/* Responsive adjustments */
@media (max-width: 600px) {
    #name-input-overlay {
        padding-top: 12px; /* Further reduce padding */
        padding-bottom: 8px;
        padding-left: 12px;
        padding-right: 12px;
    }
    #name-input-overlay h2 {
        font-size: 1em;
    }
    #name-input-overlay p {
        font-size: 0.65em;
        margin-bottom: 3px;
    }
    #name-input-overlay .fullscreen-hint {
        font-size: 0.55em;
        margin-bottom: 6px;
    }
    #player-name-input {
        font-size: 0.85em;
        padding: 5px;
        margin-bottom: 6px;
    }
    #start-game-button {
        font-size: 0.75em;
        padding: 6px 12px;
    }
    .button-container {
        gap: 6px;
        margin-bottom: 6px;
    }
    #achievements-button, #close-achievements-button {
        font-size: 0.75em;
        padding: 5px 10px;
    }
    #how-to-play-button {
        font-size: 0.75em; /* Ensure consistency */
        padding: 5px 10px;
        margin: 4px auto; /* Match achievements button */
    }
    #achievement-notification {
        font-size: 0.9em;
        padding: 8px 15px;
    }
    #achievements-modal .modal-content {
        font-size: 0.7em;
    }
    #leaderboard-display {
        margin-top: 6px;
        max-height: 80px; /* Further reduced height */
        font-size: 0.6em;
        padding: 3px 6px;
    }
}

@media (max-width: 450px) {
    #name-input-overlay {
        padding-top: 10px;
        padding-bottom: 6px;
        padding-left: 10px;
        padding-right: 10px;
    }
    #name-input-overlay h2 {
        font-size: 0.9em;
    }
    #name-input-overlay p {
        font-size: 0.6em;
        margin-bottom: 2px;
    }
    #name-input-overlay .fullscreen-hint {
        font-size: 0.5em;
        margin-bottom: 4px;
    }
    #player-name-input {
        font-size: 0.8em;
        padding: 4px;
        margin-bottom: 4px;
    }
    #start-game-button {
        font-size: 0.65em;
        padding: 5px 10px;
    }
    .button-container {
        gap: 4px;
        margin-bottom: 4px;
    }
    #achievements-button, #close-achievements-button {
        font-size: 0.65em;
        padding: 4px 8px;
    }
    #how-to-play-button {
        font-size: 0.65em; /* Ensure consistency */
        padding: 4px 8px;
        margin: 3px auto; /* Match achievements button */
    }
    #achievement-notification {
        font-size: 0.8em;
        padding: 6px 12px;
    }
    #leaderboard-display {
        max-height: 60px; /* Further reduced */
        font-size: 0.55em;
        padding: 2px 4px;
        display: block; /* Ensure visibility on small screens */
    }
}

/* Share Score Button */
#share-score-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.9em;
    padding: 10px 20px;
    background-color: #2774AE; /* Matches start-game-button */
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin-top: 15px;
    display: block;
    margin-left: auto;
    margin-right: auto;
}

#share-score-button:hover {
    background-color: #1E5A8C;
}

/* Copied Notification */
#copied-notification {
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Press Start 2P', cursive;
    font-size: 1em;
    color: #FFD700; /* Gold for visibility */
    background-color: rgba(0, 0, 0, 0.7);
    padding: 10px 20px;
    border-radius: 8px;
    z-index: 25;
    display: none;
    text-align: center;
    animation: fadeOutNotification 1.5s forwards;
}

/* Reuse existing fadeOutNotification animation */
@keyframes fadeOutNotification {
    0% { opacity: 1; transform: translateX(-50%) translateY(0); }
    80% { opacity: 1; transform: translateX(-50%) translateY(0); }
    100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
}

/* Responsive adjustments */
@media (max-width: 600px) {
    #share-score-button {
        font-size: 0.8em;
        padding: 8px 15px;
    }
    #copied-notification {
        font-size: 0.9em;
        padding: 8px 15px;
    }
}

@media (max-width: 450px) {
    #share-score-button {
        font-size: 0.7em;
        padding: 6px 12px;
    }
    #copied-notification {
        font-size: 0.8em;
    }
}
        /* In-Game UI */
        .ui-overlay { position: absolute; top: 10px; left: 15px; right: 15px; display: flex; justify-content: space-between; align-items: flex-start; color: #ffffff; font-size: 1em; z-index: 10; pointer-events: none; visibility: hidden; }
        .ui-left, .ui-center, .ui-right { display: flex; flex-direction: column; gap: 5px; }
        .ui-left { align-items: flex-start; } .ui-center { align-items: center; } .ui-right { align-items: flex-end; }
        .score, .lives, .level, .high-score-display, .high-level-display, .player-name-display, .combo-display, .bonus-display { background-color: rgba(39, 116, 174, 0.7); padding: 5px 10px; border-radius: 5px; white-space: nowrap; }
        .level { font-size: 0.9em; }
        .high-score-display, .high-level-display { font-size: 0.8em; background-color: rgba(0, 0, 0, 0.5); }
.player-name-display { position: absolute; bottom: 10px;       /* Keep position or adjust slightly if desired */ left: 10px;        /* Keep position or adjust slightly if desired */ font-size: 0.8em;    /* Keep size or adjust if desired */ z-index: 10; /* --- CHANGES START HERE --- */ background-color: rgba(39, 116, 174, 0.7); /* Match other UI background */ color: #000000;                          /* Explicitly set black text */ padding: 5px 8px;                        /* Add some padding */ border-radius: 5px;                      /* Match other UI rounding */ text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Add shadow for clarity */ white-space: nowrap;                     /* Prevent wrapping if name is long */ /* --- CHANGES END HERE --- */ }        .combo-display { position: absolute; bottom: 10px; right: 10px; font-size: 1.1em; color: #FFD700; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); z-index: 10; display: none; }
         .bonus-display { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); font-size: 1.2em; color: #ff4500; background-color: rgba(255, 255, 0, 0.8); z-index: 15; display: none; padding: 5px 15px; animation: pulseBonus 1s infinite alternate; }
         @keyframes pulseBonus { from { transform: translateX(-50%) scale(1); } to { transform: translateX(-50%) scale(1.1); } }
        .message { /* Game Over Message */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #2774AE; font-size: 1.2em; text-align: center; display: none; background-color: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 10px; border: 3px solid #2774AE; z-index: 20; line-height: 1.5; max-width: 80%; box-shadow: 0 0 15px rgba(0,0,0,0.2); cursor: pointer; }
        .level-up-message { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; font-size: 1.8em; text-align: center; display: none; z-index: 25; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); animation: fadeOutLevelUp 1.5s forwards; }
        @keyframes fadeOutLevelUp { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }
        /* Item Notification Style */
        #item-notification { position: absolute; top: 60%; left: 50%; transform: translateX(-50%); font-size: 1.3em; color: white; padding: 8px 15px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.6); z-index: 22; display: none; text-align: center; text-shadow: 1px 1px 2px black; animation: fadeOutNotification 1.5s forwards; }
        @keyframes fadeOutNotification { 0% { opacity: 1; transform: translateX(-50%) translateY(0); } 80% { opacity: 1; transform: translateX(-50%) translateY(0); } 100% { opacity: 0; transform: translateX(-50%) translateY(-20px); } }

        /* Responsive */
         @media (max-width: 600px) { .intro-text { font-size: 0.8em; } .ui-overlay { font-size: 0.9em; top: 8px; left: 12px; right: 12px; } .score, .lives, .level, .high-score-display, .high-level-display, .player-name-display, .combo-display, .bonus-display { padding: 4px 8px; } .combo-display { font-size: 1em; bottom: 8px; right: 8px;} .bonus-display { font-size: 1em; top: 45px; } .message { font-size: 1em; padding: 15px; } .level-up-message { font-size: 1.5em; } #name-input-overlay h2 { font-size: 1.1em; } #name-input-overlay p { font-size: 0.7em; } #name-input-overlay .fullscreen-hint { font-size: 0.6em; } #player-name-input { font-size: 0.9em; } #start-game-button { font-size: 0.9em; } .player-name-display { font-size: 0.7em; bottom: 8px; left: 8px; padding: 4px 6px;} #leaderboard-display { font-size: 0.65em; /* Slightly smaller font */ max-height: 120px; /* Make it shorter on medium screens */ margin-top: 10px; padding: 4px 8px; } #leaderboard-list li { padding: 2px 0; } /* ... other rules ... */ }
         @media (max-width: 450px) { .intro-text { font-size: 0.7em; } .ui-overlay { font-size: 0.75em; left: 10px; right: 10px; } .level { font-size: 0.7em; } .high-score-display, .high-level-display { font-size: 0.65em; padding: 3px 6px;} .combo-display { font-size: 0.9em; } .bonus-display { font-size: 0.9em; } .message { font-size: 0.9em; padding: 10px; } .level-up-message { font-size: 1.2em; } .player-name-display { font-size: 0.65em; } #leaderboard-display { display: none; } #item-notification { font-size: 1em; } }
        @media (max-width: 768px) { .fullscreen-hint { display: none; /* Hide 'Press F' text on smaller screens */ } #fullscreen-button { display: inline-block; /* Show fullscreen button on smaller screens */ } }
        #how-to-play-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8em;
    padding: 8px 15px;
    background-color: #f0ad4e; /* An orange color */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    margin-top: 15px; /* Space it from elements above */
    flex-shrink: 0;
}

#how-to-play-button:hover {
    background-color: #ec971f;
}

.modal-overlay {
    position: fixed; /* Cover the whole screen */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
    z-index: 100; /* Make sure it's on top */
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
}

.modal-content {
    background-color: #fff;
    color: #333; /* Text color for modal content */
    padding: 25px;
    border-radius: 10px;
    max-width: 500px; /* Max width of modal */
    width: 90%;
    text-align: left;
    font-size: 0.8em;
    line-height: 1.6;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    max-height: 80vh; /* Max height */
    overflow-y: auto; /* Scroll if content is too tall */
}

.modal-content h2 {
    font-size: 1.3em;
    color: #2774AE; /* Match your theme blue */
    text-align: center;
    margin-top: 0;
    margin-bottom: 15px;
}

.modal-content ul {
    list-style: none;
    padding-left: 10px;
}
.modal-content li {
    margin-bottom: 8px;
}

.modal-content button { /* Style for close button inside modal */
    font-family: 'Press Start 2P', cursive;
    font-size: 0.9em;
    padding: 10px 20px;
    background-color: #2774AE;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: block; /* Make it a block to center it */
    margin: 20px auto 0 auto; /* Center it */
}

.modal-content button:hover {
    background-color: #1E5A8C;
}
    </style>
</head>
<body>
    <div id="how-to-play-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>How to Play Bruin Catch</h2>
            <p>üêª <strong>Move the Bruin:</strong> Use Left/Right Arrow keys or Drag with your mouse/finger.</p>
            <p>üåü <strong>Catch Items:</strong></p>
            <ul>
                <li>üéì üìö üèÄ üèÜ: Good items! Score points!</li>
                <li>üåü (Golden): Bonus points!</li>
                <li>üíé (Diamond): Ultra bonus points!</li>
                <li>üíô (Life): Gain an extra life!</li>
                <li>üçÑ (Grow): Bruin gets bigger temporarily!</li>
                <li>üíß (Shrink): Bruin gets smaller temporarily!</li>
                <li>üß≤ (Magnet): Attracts good items for a bit!</li>
                <li>‚è≥ (Slow-Mo): Slows down items for a bit!</li>
            </ul>
            <p>‚ö†Ô∏è <strong>Avoid Bad Items:</strong></p>
            <ul>
                <li>üóëÔ∏è üí• üíî: These have red sparkles! Avoid them or lose a life!</li>
            </ul>
            <p>üî• <strong>Combos:</strong> Catch multiple good items in a row for score multipliers!</p>
            <p>üöÄ <strong>Level Up:</strong> Score points to reach higher levels. The game gets faster!</p>
            <p>üéâ <strong>Bonus Rounds:</strong> Extra valuable items might appear!</p>
            <button id="close-how-to-play-modal">Close</button>
        </div>
    </div>
    <div id="achievements-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2>Achievements</h2>
        <div id="achievements-list"></div>
        <button id="close-achievements-button">Close</button>
    </div>
</div>

<div class="game-container" id="gameContainer" tabindex="0">
<div id="name-input-overlay">
    <h2>Enter Player Name</h2>
    <p>Move üêª to catch falling items.<br>Avoid red-sparkled items!<br>Reach the highest level!</p>
    <p class="fullscreen-hint">(Press 'F' for Fullscreen)</p>
    <input type="text" id="player-name-input" placeholder="Bruin" maxlength="15">
    <div class="button-container">
        <button id="start-game-button">Start Game</button>
        <button id="fullscreen-button" title="Toggle Fullscreen">‚õ∂</button>
        <button id="sound-toggle-button" title="Toggle Sound">üîä</button>
    </div>
    <button id="achievements-button">Achievements</button>
    <button id="how-to-play-button">How to Play?</button>
    <div id="leaderboard-display">
        <h3>Leaderboard</h3>
        <ol id="leaderboard-list">
            <li>Loading...</li>
        </ol>
    </div>
</div>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <div class="ui-left">
            <div id="score" class="score">Score: 0</div>
            <div id="high-score" class="high-score-display">Hi: 0 (Bruin)</div>
        </div>
        <div class="ui-center">
            <div id="level" class="level">Level: 1</div>
            <div id="high-level" class="high-level-display">Hi Lvl: 1</div>
        </div>
        <div class="ui-right">
            <div id="lives" class="lives">Lives: 3</div>
        </div>
    </div>

    <div id="player-name-display" class="player-name-display">Player: Bruin</div>
    <div id="combo-display" class="combo-display"></div>
    <div id="bonus-display" class="bonus-display">BONUS ROUND!</div>
    <div id="message" class="message">Tap or Click to Start</div>
    <div id="levelUpMessage" class="level-up-message">Level Up!</div>
    <div id="item-notification"></div>
    <div id="copied-notification">Copied!</div>
    <div id="achievement-notification">Achievement Unlocked!</div>
</div>


    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const levelElement = document.getElementById('level');
        const highScoreElement = document.getElementById('high-score');
        const highLevelElement = document.getElementById('high-level');
        const messageElement = document.getElementById('message');
        const levelUpMessageElement = document.getElementById('levelUpMessage');
        const nameInputOverlay = document.getElementById('name-input-overlay');
        const playerNameInput = document.getElementById('player-name-input');
        const startGameButton = document.getElementById('start-game-button');
        const uiOverlay = document.querySelector('.ui-overlay');
        const playerNameDisplayElement = document.getElementById('player-name-display');
        const leaderboardListElement = document.getElementById('leaderboard-list');
        const comboDisplayElement = document.getElementById('combo-display');
        const bonusDisplayElement = document.getElementById('bonus-display');
        const itemNotificationElement = document.getElementById('item-notification');
        const fullscreenButton = document.getElementById('fullscreen-button'); // Get the new button
        const soundToggleButton = document.getElementById('sound-toggle-button');
        const howToPlayButton = document.getElementById('how-to-play-button');
const howToPlayModal = document.getElementById('how-to-play-modal');
const closeHowToPlayModalButton = document.getElementById('close-how-to-play-modal');
function showAchievementsModal() {
    const modal = document.getElementById('achievements-modal');
    const list = document.getElementById('achievements-list');
    if (modal && list) {
        list.innerHTML = achievements.map(achievement => {
            const progress = achievement.progress(); // Get progress as a fraction (0 to 1)
            const progressPercentage = (progress * 100).toFixed(0); // Convert to percentage
            return `
                <div class="achievement-item ${achievement.unlocked ? 'unlocked' : 'locked'}">
                    <strong>${achievement.name}</strong>: ${achievement.description}
                    ${achievement.unlocked ? '' : '<span>(Locked)</span>'}
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercentage}%"></div>
                    </div>
                    <div class="progress-text">${progressPercentage}%</div>
                </div>
            `;
        }).join('');
        modal.style.display = 'flex';
        if (document.fullscreenElement === gameContainer) {
            if (modal.parentNode !== gameContainer) {
                gameContainer.appendChild(modal);
                modalWasMovedForFullscreen = true;
            }
        } else {
            if (modal.parentNode !== originalModalParent && originalModalParent) {
                originalModalParent.appendChild(modal);
            }
        }
    }
}

function closeAchievementsModal() {
    const modal = document.getElementById('achievements-modal');
    if (modal) {
        modal.style.display = 'none';
        if (modalWasMovedForFullscreen && modal.parentNode === gameContainer && originalModalParent) {
            originalModalParent.appendChild(modal);
            modalWasMovedForFullscreen = false;
        }
    }
}
        
        // --- Game Variables ---
        let player; let playerName = "Bruin";
        let items = []; let particles = [];
        let score = 0; let leaderboard = [];
        let lives = 3; let level = 1;
        let baseGameSpeed = 2; let gameSpeed = baseGameSpeed;
        let baseItemSpawnInterval = 95; let itemSpawnInterval = baseItemSpawnInterval;
        let itemTimer = 0;
        let isGameOver = true;
        let originalModalParent; // Will be set once the DOM is loaded
        let modalWasMovedForFullscreen = false;
        let animationFrameId = null;
        let touchStartX = null; let playerStartX = null; let isDragging = false;
        let comboCount = 0;
        let comboMultiplier = 1;
        let totalItemsCaught = 0;
let goldenItemsCaught = 0;
let playerAchievements = [];
        let isBonusRoundActive = false; let bonusRoundTimer = 0;
        let isPlayerBig = false; let playerBigTimer = 0;
        let isPlayerSmall = false; let playerSmallTimer = 0;
        let isSlowMo = false;
let slowmoTimer = 0;
let isMagnet = false;
let magnetTimer = 0;
        let highestCombo = 1; // Track the highest combo achieved in the session
        let passiveScoreTimer = 0;
        let notificationTimeoutId = null;

// --- Constants ---
const LEADERBOARD_KEY = 'bruinCatchLeaderboard_v2'; // Local storage fallback key
        const ACHIEVEMENTS_KEY = 'bruinCatchAchievements';
const achievements = [
    {
        id: 'catch_100_items',
        name: 'Item Collector',
        description: 'Catch 100 items in total',
        target: 100, // Numerical target for progress
        condition: () => totalItemsCaught >= 100,
        progress: () => Math.min(totalItemsCaught / 100, 1), // Progress as a fraction (0 to 1)
        unlocked: false
    },
    {
        id: 'reach_level_10',
        name: 'Level Master',
        description: 'Reach Level 10',
        target: 10,
        condition: () => level >= 10,
        progress: () => Math.min(level / 10, 1),
        unlocked: false
    },
  {
    id: 'combo_10x',
    name: 'Combo King',
    description: 'Achieve a 10x Combo',
    target: 10,
    condition: () => highestCombo >= 10,
    progress: () => Math.min(highestCombo / 10, 1),
    unlocked: false
},
    {
        id: 'first_golden',
        name: 'Golden Touch',
        description: 'Catch your first Golden Item',
        target: 1,
        condition: () => goldenItemsCaught >= 1,
        progress: () => Math.min(goldenItemsCaught / 1, 1),
        unlocked: false
    }
];
// Correct paths for deployed Netlify functions
const NETLIFY_SAVE_SCORE_URL = '/.netlify/functions/save-score';
const NETLIFY_GET_SCORES_URL = '/.netlify/functions/get-scores';

        // Leveling
        const levelThresholds = [100, 250, 500, 800, 1200, 2000, 3000, 4000, 5500]; // Score needed for next level
        const levelSpeedIncrease = 0.5;      // Speed increase per level
        const levelIntervalDecrease = 10;     // Spawn interval decrease per level (in frames)
        const MIN_ITEM_SPAWN_INTERVAL = 20; // Minimum spawn interval

        // Player
        const basePlayerWidth = 40;
        const basePlayerHeight = 40;
        const playerEmoji = 'üêª';
        const playerSpeed = 9;               // Movement speed
        const playerAnimSpeed = 10;          // Frames for half of the 'wobble' animation
        const PLAYER_ANIM_SCALE_FACTOR = 1.05; // Scale factor during animation
        const PLAYER_BIG_SIZE_MULTIPLIER = 1.5; // Multiplier for Grow item
        const PLAYER_SMALL_SIZE_MULTIPLIER = 0.6; // Multiplier for Shrink item
        const playerBigDuration = 480;       // Frames the Grow effect lasts
        const playerSmallDuration = 480;     // Frames the Shrink effect lasts

        // Items
        const itemSize = 35;
        const goodItems = ['üéì', 'üìö', 'üèÄ', 'üèÜ'];
        const badItems = ['üóëÔ∏è', 'üí•', 'üíî'];
        const goldenItemEmoji = 'üåü';
        const superRareItemEmoji = 'üíé';
        const lifeItemEmoji = 'üíô';
        const growItemEmoji = 'üçÑ';
        const shrinkItemEmoji = 'üíß';
        const magnetItemEmoji = 'üß≤';
const magnetItemType = 'magnet';
        const slowmoItemEmoji = '‚è≥';
const slowmoItemType = 'slowmo';
const slowmoDuration = 480; // Frames (~8 seconds at 60fps)
const slowmoSpeedMultiplier = 0.5; // Reduce item speeds to 50%
const SLOWMO_PARTICLE_COUNT = 15;
const SLOWMO_PARTICLE_SPEED = 4;
const slowmoParticleColor = '#4682B4'; // Steel Blue

const magnetDuration = 480; // Frames (~8 seconds at 60fps)
const magnetStrength = 2; // Pixels per frame good items move toward player
const MAGNET_PARTICLE_COUNT = 15;
const MAGNET_PARTICLE_SPEED = 4;
const magnetParticleColor = '#A9A9A9'; // Dark Grey

        // Item Spawning Probabilities (Cumulative Thresholds)
        const SUPER_RARE_THRESHOLD = 0.01;  // 1% chance
        const GOLDEN_THRESHOLD = 0.02;      // 1% chance (cumulative 2%)
        const LIFE_THRESHOLD = 0.035;       // 1.5% chance (cumulative 3.5%)
        const GROW_THRESHOLD = 0.040;       // 0.5% chance (cumulative 4.0%)
        const SHRINK_THRESHOLD = 0.045;     // 0.5% chance (cumulative 4.5%)
        const BAD_ITEM_THRESHOLD = 0.305;   // 26% chance (cumulative 30.5%)
        const MAGNET_THRESHOLD = 0.050; // 0.5% chance (cumulative 5.0%)
const SLOWMO_THRESHOLD = 0.055; // 0.5% chance (cumulative 5.5%)
        // Good items are the remaining percentage (100 - 30.5 = 69.5%)

        // Bonus Round Item Probabilities (Cumulative Thresholds)
        const BONUS_SUPER_RARE_THRESHOLD = 0.07; // 7% chance
        const BONUS_GOLDEN_THRESHOLD = 0.15;     // 8% chance (cumulative 15%)
        // Good items are the remaining percentage (100 - 15 = 85%)

        // Item Scoring & Effects
        const itemValue = 10;
        const goldenItemValue = 30;
        const superRareItemValue = 100;
        const penaltyValue = 0; // Score penalty for bad item (can be negative)
        const missPenalty = 1;  // Lives lost for missing a standard good item
        const superRareSpeedMultiplier = 2.1; // How much faster super rare items fall

        // Combo System
        const comboThreshold = 3;           // Catches needed to start combo multiplier
        const maxComboMultiplier = 5;       // Maximum combo multiplier

        // Bonus Round
        const bonusRoundDuration = 600;      // Duration in frames (e.g., 10 seconds at 60fps)
        const BONUS_ROUND_TRIGGER_CHANCE = 0.0001; // Chance per frame to trigger (if level >= 3)
        const MIN_LEVEL_FOR_BONUS = 3;       // Minimum level required for bonus round possibility

        // Passive Score
        const passiveScoreInterval = 60;     // Frames between passive score checks
        const smallPassiveScore = 2;        // Score per interval when small
        const bigPassiveScore = 1;          // Score per interval when big

        // Particles
        const particleLifespan = 40;        // Base lifespan in frames
        const PARTICLE_LIFESPAN_VARIATION = 20; // Random additional lifespan
        const PARTICLE_BASE_SIZE = 2;       // Minimum particle size
        const PARTICLE_SIZE_VARIATION = 4;  // Random additional size
        const PARTICLE_GRAVITY = 0.05;      // Downward acceleration for particles
        const DEFAULT_PARTICLE_COUNT = 8;
        const DEFAULT_PARTICLE_SPEED = 3;

        // Particle Effects per Item Type
        const SUPER_RARE_PARTICLE_COUNT = 40;
        const SUPER_RARE_PARTICLE_SPEED = 6;
        const GOLDEN_PARTICLE_COUNT = 25;
        const GOLDEN_PARTICLE_SPEED = 5;
        const GOOD_PARTICLE_COUNT = 8;
        const GOOD_PARTICLE_SPEED = 3;
        const LIFE_PARTICLE_COUNT = 15;
        const LIFE_PARTICLE_SPEED = 4;
        const GROW_PARTICLE_COUNT = 15;
        const GROW_PARTICLE_SPEED = 4;
        const SHRINK_PARTICLE_COUNT = 15;
        const SHRINK_PARTICLE_SPEED = 4;
        const BAD_HIT_PARTICLE_COUNT = 15;
        const BAD_HIT_PARTICLE_SPEED = 4;

        // Item Visual Effects
        const BAD_ITEM_SPARKLE_CHANCE = 0.3; // Chance per frame for bad item sparkle
        const BAD_SPARKLE_COUNT = 1;
        const BAD_SPARKLE_SPEED = 1.8;
        const GOLDEN_ITEM_SHADOW_BLUR = 10;
        const SUPER_RARE_ITEM_SHADOW_BLUR = 12;
        const SUPER_RARE_SPARKLE_CHANCE = 0.4; // Chance per frame for super rare sparkle
        const SUPER_RARE_SPARKLE_COUNT = 1;
        const SUPER_RARE_SPARKLE_SPEED = 1.2;
        const POWERUP_ITEM_SHADOW_BLUR = 8; // For Life, Grow, Shrink

        // Colors
        const goodParticleColor = '#FFD700'; // Yellow/Gold
        const badParticleColor = '#DC143C';  // Crimson Red
        const goldenParticleColor = '#FFFF00'; // Bright Yellow
        const badItemSparkleColor = 'rgba(255, 0, 0, 0.8)'; // Red Sparkle
        const superRareParticleColor = '#FFFFFF'; // White/Diamond
        const lifeParticleColor = '#00BFFF';  // Deep Sky Blue
        const growParticleColor = '#32CD32';  // Lime Green
        const shrinkParticleColor = '#8A2BE2'; // Blue Violet
        let themeColors = {
            sky1: '#87CEEB', sky2: '#ADD8E6', // Sky gradient
            ground1: '#8B4513', ground2: '#A0522D', // Ground gradient
            bodyBg: '#e0f2fe' // Potential body background (not currently used in style block)
        };

        // Misc UI/Layout
        const groundHeight = 20;
        const ITEM_NOTIFICATION_DURATION = 1500; // ms for item notification display
        let groundY; // Calculated based on canvas height

// --- Global variables for sound ---
let jumpSynth, collectSynth, hurtSynth, levelUpSynth, bonusSynth, powerupSynth;
let soundsEnabled = false;
let soundGloballyEnabled = true; // Default to on, will be updated from localStorage
 function initAudio() {
    if (typeof Tone === 'undefined') {
        console.log("Tone is undefined in initAudio.");
        soundsEnabled = false; 
        return; 
    }

    if (!soundGloballyEnabled) {
        soundsEnabled = false; 
        console.log("Audio globally disabled, initAudio() did not initialize synths.");
        return; 
    }

    console.log("initAudio() called, soundGloballyEnabled is true.");
    if (Tone.context.state !== 'running') {
        Tone.start().then(() => {
            console.log("Audio Context Started by initAudio()");
            initAudioInternal(); 
        }).catch(e => {
            console.error("Audio context start failed in initAudio():", e);
            soundsEnabled = false;
        });
    } else { 
        if (!collectSynth) {
            console.log("Audio Context running, calling initAudioInternal() to create synths.");
            initAudioInternal(); 
        } else {
            console.log("Audio Context running and synths exist. Ensuring soundsEnabled is true.");
            soundsEnabled = true; 
        }
    }
}
let lastHurtSynthTime = 0;
function playSound(type, note = 'C4', duration = '8n') {
    if (!soundsEnabled || !soundGloballyEnabled || typeof Tone === 'undefined') return;
    if (Tone.context.state !== 'running') {
        console.warn("Audio context not running, attempting to start");
        Tone.start().catch(e => console.error("Audio context start failed:", e));
        return;
    }
    try {
        const now = Tone.now();
        if (type === 'bad' || type === 'miss' || type === 'gameOver') {
            if (now < lastHurtSynthTime + 0.1) {
                console.log("Skipping hurtSynth call due to timing conflict");
                return;
            }
            lastHurtSynthTime = now;
        }
        if (type === 'good' && collectSynth) collectSynth.triggerAttackRelease('C5', '16n', now);
        else if (type === 'golden' && collectSynth) collectSynth.triggerAttackRelease('E5', '16n', now + 0.01);
        else if (type === 'superRare' && collectSynth) collectSynth.triggerAttackRelease('G5', '8n', now + 0.02);
        else if (type === 'bad' && hurtSynth) hurtSynth.triggerAttackRelease('C3', '8n', now);
        else if (type === 'miss' && hurtSynth) hurtSynth.triggerAttackRelease('A2', '16n', now);
        else if (type === 'life' && powerupSynth) powerupSynth.triggerAttackRelease('A4', '8n', now);
        else if (type === 'grow' && powerupSynth) powerupSynth.triggerAttackRelease('E4', '8n', now);
        else if (type === 'shrink' && powerupSynth) powerupSynth.triggerAttackRelease('C4', '8n', now);
        else if (type === 'slowmo' && powerupSynth) powerupSynth.triggerAttackRelease('G4', '8n', now);
        else if (type === 'magnet' && powerupSynth) powerupSynth.triggerAttackRelease('A4', '8n', now);
        else if (type === 'levelUp' && levelUpSynth) levelUpSynth.triggerAttackRelease('G4', '4n', now);
        else if (type === 'bonusStart' && bonusSynth) bonusSynth.triggerAttackRelease('C5', '2n', now);
        else if (type === 'gameOver' && hurtSynth) hurtSynth.triggerAttackRelease('F2', '1n', now);
    } catch (e) {
        console.error("Sound playback error:", e);
    }
}
function initAudioInternal() {
    if (typeof Tone === 'undefined') return;
    if (collectSynth) return; // Synths already initialized

    console.log("initAudioInternal() - Creating sound synthesizers...");
    jumpSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
    collectSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination();
    hurtSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).toDestination();
    levelUpSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.3 } }).toDestination();
    bonusSynth = new Tone.Synth({ oscillator: { type: 'pulse', width: 0.4 }, envelope: { attack: 0.1, decay: 0.4, sustain: 0.2, release: 0.5 } }).toDestination();
    powerupSynth = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -6, envelope: { attack: 0.02, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
    
    soundsEnabled = true; 
    console.log("Audio Synths Initialized by initAudioInternal(). soundsEnabled: true");
}
        
function openHowToPlayModal() {
    if (!howToPlayModal || !gameContainer || !document.body) {
        console.error("MODAL_DEBUG: openHowToPlayModal - Crucial elements missing. Modal:", !!howToPlayModal, "GameContainer:", !!gameContainer, "Body:", !!document.body);
        return;
    }

    // Ensure originalModalParent is correctly captured.
    // It should be where the modal is when NOT in fullscreen (typically document.body).
    if (!originalModalParent && howToPlayModal.parentNode && howToPlayModal.parentNode !== gameContainer) {
        originalModalParent = howToPlayModal.parentNode;
    } else if (!originalModalParent) {
        // This is a fallback if the modal somehow had no parent on load.
        originalModalParent = document.body;
    }
    console.log("MODAL_DEBUG: openHowToPlayModal - Current modal parent:", howToPlayModal.parentNode ? (howToPlayModal.parentNode.id || howToPlayModal.parentNode.tagName) : "none");
    console.log("MODAL_DEBUG: openHowToPlayModal - Intended originalModalParent:", originalModalParent ? (originalModalParent.id || originalModalParent.tagName) : "none");
    console.log("MODAL_DEBUG: openHowToPlayModal - Is gameContainer fullscreen?", document.fullscreenElement === gameContainer);

    if (document.fullscreenElement === gameContainer) {
        // If game is fullscreen, modal MUST be a child of gameContainer to be visible
        if (howToPlayModal.parentNode !== gameContainer) {
            console.log("MODAL_DEBUG: Game IS fullscreen. Moving modal INTO gameContainer.");
            gameContainer.appendChild(howToPlayModal);
            modalWasMovedForFullscreen = true; // Set flag
        } else {
            console.log("MODAL_DEBUG: Game IS fullscreen. Modal already in gameContainer.");
        }
    } else {
        // If game is NOT fullscreen, modal should be a child of its original parent
        if (howToPlayModal.parentNode !== originalModalParent && originalModalParent) {
            console.log("MODAL_DEBUG: Game NOT fullscreen. Modal not in original parent. Moving to original parent:", originalModalParent.id || originalModalParent.tagName);
            originalModalParent.appendChild(howToPlayModal);
        } else if (!howToPlayModal.parentNode && originalModalParent) { // If modal was somehow detached
            console.log("MODAL_DEBUG: Game NOT fullscreen. Modal has no parent. Moving to original parent:", originalModalParent.id || originalModalParent.tagName);
            originalModalParent.appendChild(howToPlayModal);
        } else {
            console.log("MODAL_DEBUG: Game NOT fullscreen. Modal already in correct parent or originalModalParent is null/invalid.");
        }
        modalWasMovedForFullscreen = false; // Reset flag
    }
    howToPlayModal.style.display = 'flex';
    console.log("MODAL_DEBUG: Modal display set to flex. New parent:", howToPlayModal.parentNode ? (howToPlayModal.parentNode.id || howToPlayModal.parentNode.tagName) : "none");
}

// Function to close the "How to Play" modal
function closeHowToPlayModal() {
    if (!howToPlayModal) return;
    howToPlayModal.style.display = 'none';
    console.log("closeHowToPlayModal: Modal hidden.");

    // If the modal was moved for fullscreen and is currently in gameContainer, move it back
    if (modalWasMovedForFullscreen && howToPlayModal.parentNode === gameContainer && originalModalParent) {
        console.log("Closing modal that was in fullscreen gameContainer. Moving back to original parent:", originalModalParent.tagName);
        originalModalParent.appendChild(howToPlayModal);
    }
    modalWasMovedForFullscreen = false; // Reset flag on close
}

function startGame() {
    playerName = playerNameInput.value.trim();
    if (playerName.length > 15) {
        playerName = playerName.slice(0, 15);
        playerNameInput.value = playerName;
    }
    if (!playerName) playerName = "Bruin";
    nameInputOverlay.style.display = 'none';
    gameContainer.focus();
    isGameOver = false;
    score = 0;
    lives = 3;
    level = 1;
    gameSpeed = INITIAL_GAME_SPEED;
    itemSpawnInterval = INITIAL_ITEM_SPAWN_INTERVAL;
    items = [];
    particles = [];
    comboCount = 0;
    comboMultiplier = 1;
    highestCombo = 1; // Reset highest combo
    passiveScoreTimer = 0;
    totalItemsCaught = 0;
    goldenItemsCaught = 0;
    isPlayerBig = false;
    playerBigTimer = 0;
    isPlayerSmall = false;
    playerSmallTimer = 0;
    isBonusRoundActive = false;
    bonusRoundTimer = 0;
    bonusRoundSpawnTimer = 0;
    isSlowMo = false;
    slowmoTimer = 0;
    isMagnet = false;
    magnetTimer = 0;
    player = new Player(canvas.width / 2 - PLAYER_WIDTH / 2, canvas.height - PLAYER_HEIGHT - 10);
    scoreElement.textContent = `Score: ${score}`;
    livesElement.textContent = `Lives: ${lives}`;
    levelElement.textContent = `Level: ${level}`;
    comboDisplayElement.style.display = 'none';
    messageElement.style.display = 'none';
    loadAchievements();
    animationFrameId = requestAnimationFrame(gameLoop);
}
// --- Modify initAudio() slightly ---
                    
        // --- Leaderboard Handling ---
        function loadLocalLeaderboard() { // Fallback loader
             try { const storedData = localStorage.getItem(LEADERBOARD_KEY); leaderboard = storedData ? JSON.parse(storedData) : []; if (!Array.isArray(leaderboard)) leaderboard = []; leaderboard.sort((a, b) => b.score - a.score || b.level - a.level); } catch (e) { console.error("LS Error (Load Leaderboard):", e); leaderboard = []; } finally { /* Display handled by caller or loadRemoteLeaderboard */ }
        }

        function saveToLeaderboard() {
             if (!playerName) {
                 playerName = "Bruin"; // Fallback if no name somehow
             }
             const scoreData = { name: playerName, score: score, level: level };

             // --- ADDED: Server-Side Security Note ---
             // IMPORTANT: The Netlify function at NETLIFY_SAVE_SCORE_URL MUST validate
             // this incoming 'scoreData' on the server-side.
             // - Check if 'name' is a reasonable string (length, content).
             // - Check if 'score' and 'level' are positive integers within expected ranges.
             // - Implement rate limiting to prevent spamming.
             // DO NOT TRUST client-side data directly!

             fetch(NETLIFY_SAVE_SCORE_URL, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json', },
                 body: JSON.stringify(scoreData),
             })
             .then(response => {
                 // --- MODIFIED: Check response status before parsing JSON ---
                 if (!response.ok) {
                     // Throw an error to trigger the .catch block (fallback)
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 return response.json(); // Only parse if response is ok
             })
             .then(data => {
                 console.log('Score saved via server:', data);
                 loadRemoteLeaderboard(); // Fetch the updated leaderboard from the server
             })
             .catch(error => {
                 console.error('Error saving score to server:', error);
                 // Fallback to local storage if server save fails
                 console.warn('Falling back to local storage for saving score.');
                 try {
                     // Load current local data first to merge correctly
                     loadLocalLeaderboard();

                     const currentEntry = { name: playerName, score: score, level: level };
                     let playerIndex = leaderboard.findIndex(entry => entry.name === playerName);

                     if (playerIndex !== -1) { // Player exists
                         // Update only if new score is better (higher score, or same score with higher level)
                         if (score > leaderboard[playerIndex].score || (score === leaderboard[playerIndex].score && level > leaderboard[playerIndex].level)) {
                             leaderboard[playerIndex] = currentEntry;
                         } else {
                             return; // No update needed
                         }
                     } else { // New player
                         leaderboard.push(currentEntry);
                     }

                     leaderboard.sort((a, b) => b.score - a.score || b.level - a.level); // Sort again
                     leaderboard = leaderboard.slice(0, 5); // Keep top 5 locally

                     localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
                     console.log('Score saved locally as fallback.');
                     displayLeaderboard(); // Update display with local data
                     updateTopScoreDisplay(); // Update top score display
                 } catch (e) {
                     console.error("LS Error (Save Leaderboard - Fallback):", e);
                 }
             });
        }

        function displayLeaderboard() { if (!leaderboardListElement) return; leaderboardListElement.innerHTML = ''; if (leaderboard.length === 0) { leaderboardListElement.innerHTML = '<li>No scores yet!</li>'; return; } leaderboard.forEach((entry, index) => { const li = document.createElement('li'); const safeName = (entry.name || 'Anonymous').replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Sanitize
                 li.innerHTML = `<span class="rank">${index + 1}.</span><span class="name">${safeName}</span><span class="score">${entry.score || 0}</span><span class="level">(L${entry.level || 1})</span>`; leaderboardListElement.appendChild(li); }); }

        function updateTopScoreDisplay() {
             let personalHighScore = 0;
             let topScore = 0;
             let topPlayerName = "Bruin";
             let personalHighLevel = 1;
             let topLevel = 1;

             if (leaderboard.length > 0) {
                topScore = leaderboard[0].score || 0;
                topPlayerName = (leaderboard[0].name || "Bruin").replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Sanitize
                topLevel = leaderboard[0].level || 1;

                for (const entry of leaderboard) {
                     if (entry.name === playerName) {
                         const currentEntryScore = entry.score || 0;
                         const currentEntryLevel = entry.level || 1;
                         if(currentEntryScore > personalHighScore) {
                             personalHighScore = currentEntryScore;
                             personalHighLevel = currentEntryLevel;
                         } else if (currentEntryScore === personalHighScore && currentEntryLevel > personalHighLevel) {
                             personalHighLevel = currentEntryLevel; // Update level if score is same but level is higher
                         }
                     }
                 }
             }

             if (personalHighScore > 0) {
                 if (highScoreElement) highScoreElement.textContent = `Hi: ${personalHighScore} (${playerName.replace(/</g, "&lt;").replace(/>/g, "&gt;")})`; // Sanitize displayed name
                 if (highLevelElement) highLevelElement.textContent = `Hi Lvl: ${personalHighLevel}`;
             } else { // Show overall top score if player has no score on board or board is empty
                 if (highScoreElement) highScoreElement.textContent = `Hi: ${topScore} (${topPlayerName})`;
                 if (highLevelElement) highLevelElement.textContent = `Hi Lvl: ${topLevel}`;
             }
         }

        function resetLeaderboard() { // Resets only the LOCAL leaderboard
             try { localStorage.removeItem(LEADERBOARD_KEY); leaderboard = []; displayLeaderboard(); updateTopScoreDisplay(); console.log("Local leaderboard cache has been reset."); } catch (e) { console.error("Error resetting local leaderboard:", e); }
         }

         function loadRemoteLeaderboard() {
            fetch(NETLIFY_GET_SCORES_URL)
            .then(response => {
                // --- MODIFIED: Check response status before parsing JSON ---
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 return response.json();
             })
             .then(data => {
                 leaderboard = Array.isArray(data) ? data : []; // Ensure data is an array
                 console.log("Leaderboard loaded from server.");
                 displayLeaderboard();
                 updateTopScoreDisplay();
             })
             .catch(error => {
                 console.error('Error fetching leaderboard from server:', error);
                 // Fallback to local storage if server fetch fails
                 console.warn('Falling back to local storage for leaderboard.');
                 loadLocalLeaderboard(); // Load local data
                 displayLeaderboard();    // Display local data
                 updateTopScoreDisplay(); // Update top score based on local data
             });
        }

        // --- Resize Canvas ---
        function resizeCanvas() { canvas.width = gameContainer.clientWidth; canvas.height = gameContainer.clientHeight; groundY = canvas.height - groundHeight; // Recalculate ground position
             if (player) { // Adjust player y based on new height and ensure x is within bounds
                 player.y = groundY - player.currentHeight - 10; // Place slightly above ground line accounting for height
                 player.x = Math.max(0, Math.min(canvas.width - player.currentWidth, player.x));
             } if (!isGameOver) { drawGame(); } } // Redraw if game is active

        // --- Particle System ---
        function createParticle(x, y, count = DEFAULT_PARTICLE_COUNT, color = goodParticleColor, speed = DEFAULT_PARTICLE_SPEED, type = 'burst') { for (let i = 0; i < count; i++) { let vx, vy; const currentSpeed = Math.random() * speed * 0.8 + speed * 0.2; // Add some variation
                 if (type === 'burst') { const angle = Math.random() * Math.PI * 2; vx = Math.cos(angle) * currentSpeed; vy = Math.sin(angle) * currentSpeed; } else if (type === 'upward') { vx = (Math.random() - 0.5) * speed * 0.8; vy = -currentSpeed; } else if (type === 'radiate') { const angle = Math.random() * Math.PI * 2; vx = Math.cos(angle) * currentSpeed * 0.7; vy = Math.sin(angle) * currentSpeed * 0.7; } else { // Default to upward burst
                     vx = (Math.random() - 0.5) * speed * 1.5; vy = (Math.random() * -speed) - 1; }
                 particles.push({ x: x, y: y, vx: vx, vy: vy, life: particleLifespan + Math.random() * PARTICLE_LIFESPAN_VARIATION, size: PARTICLE_BASE_SIZE + Math.random() * PARTICLE_SIZE_VARIATION, color: color, alpha: 1.0 }); } }
        function handleParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += PARTICLE_GRAVITY; // Apply gravity
                 p.life--; p.alpha = Math.max(0, p.life / (particleLifespan + PARTICLE_LIFESPAN_VARIATION)); // Fade out based on max possible life
                 if (p.life <= 0) { particles.splice(i, 1); } else { ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size); ctx.globalAlpha = 1.0; } } }

        // --- Object Creation ---
        function createPlayer() { let playerWidth = basePlayerWidth; let playerHeight = basePlayerHeight; return { x: canvas.width / 2 - playerWidth / 2, y: groundY - playerHeight - 10, // Initial position above ground
                 baseWidth: basePlayerWidth, baseHeight: basePlayerHeight, currentWidth: playerWidth, currentHeight: playerHeight, emoji: playerEmoji, dx: 0, animFrame: 0, update: function() { let moved = false; if (this.dx !== 0) { this.x += this.dx; moved = true; this.animFrame = (this.animFrame + 1) % (playerAnimSpeed * 2); } else { this.animFrame = 0; } // Boundary checks
                 if (this.x < 0) this.x = 0; if (this.x > canvas.width - this.currentWidth) this.x = canvas.width - this.currentWidth; // Power-up timers
                 if (isPlayerBig) { playerBigTimer--; if (playerBigTimer <= 0) this.setSize('normal'); } if (isPlayerSmall) { playerSmallTimer--; if (playerSmallTimer <= 0) this.setSize('normal'); } }, draw: function() { ctx.save(); const scaleFactor = (this.dx !== 0 && this.animFrame < playerAnimSpeed) ? PLAYER_ANIM_SCALE_FACTOR : 1.0; ctx.translate(this.x + this.currentWidth / 2, this.y + this.currentHeight / 2); ctx.scale(scaleFactor, scaleFactor); ctx.font = `${this.currentHeight}px Arial`; // Use current height for font size
                 ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, 0, 0); ctx.restore(); }, setSize: function(sizeType) { isPlayerBig = false; isPlayerSmall = false; playerBigTimer = 0; playerSmallTimer = 0; if (sizeType === 'big') { this.currentWidth = this.baseWidth * PLAYER_BIG_SIZE_MULTIPLIER; this.currentHeight = this.baseHeight * PLAYER_BIG_SIZE_MULTIPLIER; isPlayerBig = true; playerBigTimer = playerBigDuration; } else if (sizeType === 'small') { this.currentWidth = this.baseWidth * PLAYER_SMALL_SIZE_MULTIPLIER; this.currentHeight = this.baseHeight * PLAYER_SMALL_SIZE_MULTIPLIER; isPlayerSmall = true; playerSmallTimer = playerSmallDuration; } else { // Normal size
                     this.currentWidth = this.baseWidth; this.currentHeight = this.baseHeight; } // Recalculate Y position based on new height and ensure X is valid
                 this.y = groundY - this.currentHeight - 10; this.x = Math.max(0, Math.min(canvas.width - this.currentWidth, this.x)); // Update legacy vars if needed elsewhere? (Probably remove these)
                 // playerWidth = this.currentWidth;
                 // playerHeight = this.currentHeight;
                }, moveLeft: function() { this.dx = -playerSpeed; }, moveRight: function() { this.dx = playerSpeed; }, stop: function() { this.dx = 0; this.animFrame = 0; } }; }

function createItem(bonusActive = false) {
    let emoji;
    let type;
    let isGood = true;
    let isGolden = false;
    let isSuperRare = false;
    let itemSpeed = gameSpeed + Math.random() * 1.5;
    const rand = Math.random();
    if (bonusActive) {
        if (rand < BONUS_SUPER_RARE_THRESHOLD) {
            emoji = superRareItemEmoji;
            type = 'superRare';
            isSuperRare = true;
            itemSpeed = gameSpeed * superRareSpeedMultiplier + Math.random() * 2;
        } else if (rand < BONUS_GOLDEN_THRESHOLD) {
            emoji = goldenItemEmoji;
            type = 'golden';
            isGolden = true;
        } else {
            emoji = goodItems[Math.floor(Math.random() * goodItems.length)];
            type = 'good';
        }
    } else {
        if (rand < SUPER_RARE_THRESHOLD) {
            emoji = superRareItemEmoji;
            type = 'superRare';
            isSuperRare = true;
            itemSpeed = gameSpeed * superRareSpeedMultiplier + Math.random() * 2;
        } else if (rand < GOLDEN_THRESHOLD) {
            emoji = goldenItemEmoji;
            type = 'golden';
            isGolden = true;
        } else if (rand < LIFE_THRESHOLD) {
            emoji = lifeItemEmoji;
            type = 'life';
        } else if (rand < GROW_THRESHOLD) {
            emoji = growItemEmoji;
            type = 'grow';
        } else if (rand < SHRINK_THRESHOLD) {
            emoji = shrinkItemEmoji;
            type = 'shrink';
        } else if (rand < MAGNET_THRESHOLD) {
            emoji = magnetItemEmoji;
            type = magnetItemType;
        } else if (rand < SLOWMO_THRESHOLD) {
            emoji = slowmoItemEmoji;
            type = slowmoItemType;
        } else if (rand < BAD_ITEM_THRESHOLD) {
            emoji = badItems[Math.floor(Math.random() * badItems.length)];
            type = 'bad';
            isGood = false;
        } else {
            emoji = goodItems[Math.floor(Math.random() * goodItems.length)];
            type = 'good';
        }
    }
    return {
        x: Math.random() * (canvas.width - itemSize),
        y: -itemSize,
        size: itemSize,
        emoji: emoji,
        type: type,
        isGood: isGood,
        isGolden: isGolden,
        isSuperRare: isSuperRare,
        speed: itemSpeed,
        update: function() {
            this.y += this.speed;
            // Apply magnet effect to good items
            if (isMagnet && this.isGood && player) {
                const dx = (player.x + player.currentWidth / 2) - (this.x + this.size / 2);
                const distance = Math.abs(dx);
                if (distance > 5) { // Avoid jittering when very close
                    this.x += (dx > 0 ? magnetStrength : -magnetStrength);
                }
            }
        },
        draw: function() {
            ctx.save();
            ctx.font = `${this.size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (this.type === 'bad' && Math.random() < BAD_ITEM_SPARKLE_CHANCE) {
                createParticle(this.x + this.size / 2, this.y + this.size / 2, BAD_SPARKLE_COUNT, badItemSparkleColor, BAD_SPARKLE_SPEED, 'radiate');
            } else if (this.isGolden) {
                ctx.shadowColor = 'rgba(255, 223, 0, 0.8)';
                ctx.shadowBlur = GOLDEN_ITEM_SHADOW_BLUR;
            } else if (this.isSuperRare) {
                ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                ctx.shadowBlur = SUPER_RARE_ITEM_SHADOW_BLUR;
                if (Math.random() < SUPER_RARE_SPARKLE_CHANCE) {
                    createParticle(this.x + this.size / 2, this.y + this.size / 2, SUPER_RARE_SPARKLE_COUNT, superRareParticleColor, SUPER_RARE_SPARKLE_SPEED, 'radiate');
                }
            } else if (this.type === 'life' || this.type === 'grow' || this.type === 'shrink' || this.type === slowmoItemType || this.type === magnetItemType) {
                if (this.type === 'life') ctx.shadowColor = 'rgba(0, 191, 255, 0.7)';
                else if (this.type === 'grow') ctx.shadowColor = 'rgba(50, 205, 50, 0.7)';
                else if (this.type === 'shrink') ctx.shadowColor = 'rgba(138, 43, 226, 0.7)';
                else if (this.type === slowmoItemType) ctx.shadowColor = 'rgba(70, 130, 180, 0.7)';
                else if (this.type === magnetItemType) ctx.shadowColor = 'rgba(169, 169, 169, 0.7)';
                ctx.shadowBlur = POWERUP_ITEM_SHADOW_BLUR;
            }
            ctx.fillText(this.emoji, this.x + this.size / 2, this.y + this.size / 2);
            ctx.restore();
        }
    };
}
function updateSoundButtonIcon() {
    if (soundToggleButton) {
        soundToggleButton.innerHTML = soundGloballyEnabled ? 'üîä' : 'üîá';
    }
}

function toggleGlobalSound() {
    soundGloballyEnabled = !soundGloballyEnabled;
    localStorage.setItem('bruinCatchSoundEnabled', soundGloballyEnabled);
    updateSoundButtonIcon();
    console.log('toggleGlobalSound - soundGloballyEnabled:', soundGloballyEnabled);

    if (soundGloballyEnabled && typeof Tone !== 'undefined') {
        if (Tone.context.state !== 'running') {
            Tone.start().then(() => {
                console.log("Audio context started by toggle.");
                if (!collectSynth) {
                    initAudioInternal();
                } else {
                    soundsEnabled = true; 
                }
            }).catch(e => {
                console.error("Audio context start failed on toggle:", e);
                soundsEnabled = false; 
            });
        } else if (!collectSynth) { 
            initAudioInternal(); 
        } else { 
            soundsEnabled = true; 
        }
    } else if (!soundGloballyEnabled) {
        soundsEnabled = false;
        console.log('Sounds globally muted, soundsEnabled set to false.');
    }
}
        // --- Game Logic ---
        function checkLevelUp() { if (level - 1 < levelThresholds.length && score >= levelThresholds[level - 1]) { level++; baseGameSpeed += levelSpeedIncrease; // --- MODIFIED: Use constant for minimum interval ---
                 baseItemSpawnInterval = Math.max(MIN_ITEM_SPAWN_INTERVAL, baseItemSpawnInterval - levelIntervalDecrease); levelElement.textContent = `Level: ${level}`; console.log(`Level Up! Level: ${level}, Speed: ${baseGameSpeed.toFixed(2)}, Interval: ${baseItemSpawnInterval}`); levelUpMessageElement.textContent = `Level ${level}!`; levelUpMessageElement.style.display = 'block'; levelUpMessageElement.style.animation = 'none'; levelUpMessageElement.offsetHeight; // Trigger reflow to restart animation
                 levelUpMessageElement.style.animation = ''; playSound('levelUp'); // Apply new settings immediately
                 gameSpeed = baseGameSpeed; itemSpawnInterval = baseItemSpawnInterval; } }
        function handleItems() {
    itemTimer++;
    if (!isBonusRoundActive && Math.random() < BONUS_ROUND_TRIGGER_CHANCE && level >= MIN_LEVEL_FOR_BONUS) {
        startBonusRound();
    }
    if (itemTimer >= itemSpawnInterval) {
        items.push(createItem(isBonusRoundActive));
        itemTimer = 0;
    }
    let soundPlayedThisFrame = false; // Track if a sound was played
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.update();
        if (player && item.x < player.x + player.currentWidth && item.x + item.size > player.x && item.y + item.size > player.y && item.y < player.y + player.currentHeight) {
            let particleX = item.x + item.size / 2;
            let particleY = item.y + item.size / 2;
            let scoreToAdd = 0;
            let soundType = 'good';
            let notificationText = null;
switch(item.type) {
    case 'superRare':
        scoreToAdd = superRareItemValue;
        createParticle(particleX, particleY, SUPER_RARE_PARTICLE_COUNT, superRareParticleColor, SUPER_RARE_PARTICLE_SPEED, 'burst');
        soundType = 'superRare';
        notificationText = "DIAMOND!";
        totalItemsCaught++;
        break;
    case 'golden':
        scoreToAdd = goldenItemValue;
        createParticle(particleX, particleY, GOLDEN_PARTICLE_COUNT, goldenParticleColor, GOLDEN_PARTICLE_SPEED, 'burst');
        soundType = 'golden';
        notificationText = "Golden Star!";
        totalItemsCaught++;
        goldenItemsCaught++;
        break;
    case 'good':
        scoreToAdd = itemValue;
        createParticle(particleX, particleY, GOOD_PARTICLE_COUNT, goodParticleColor, GOOD_PARTICLE_SPEED, 'upward');
        soundType = 'good';
        totalItemsCaught++;
        break;
    case 'life':
        lives++;
        createParticle(particleX, particleY, LIFE_PARTICLE_COUNT, lifeParticleColor, LIFE_PARTICLE_SPEED, 'upward');
        soundType = 'life';
        notificationText = "+1 Life!";
        totalItemsCaught++;
        break;
    case 'grow':
        if (!isPlayerSmall) player.setSize('big');
        createParticle(particleX, particleY, GROW_PARTICLE_COUNT, growParticleColor, GROW_PARTICLE_SPEED, 'burst');
        soundType = 'grow';
        notificationText = "Grew Big!";
        totalItemsCaught++;
        break;
    case 'shrink':
        if (!isPlayerBig) player.setSize('small');
        createParticle(particleX, particleY, SHRINK_PARTICLE_COUNT, shrinkParticleColor, SHRINK_PARTICLE_SPEED, 'burst');
        soundType = 'shrink';
        notificationText = "Shrunk Small!";
        totalItemsCaught++;
        break;
    case 'slowmo':
        isSlowMo = true;
        slowmoTimer = slowmoDuration;
        items.forEach(item => item.speed *= slowmoSpeedMultiplier);
        createParticle(particleX, particleY, SLOWMO_PARTICLE_COUNT, slowmoParticleColor, SLOWMO_PARTICLE_SPEED, 'burst');
        soundType = 'slowmo';
        notificationText = "Slow-Mo!";
        totalItemsCaught++;
        break;
    case 'magnet':
        isMagnet = true;
        magnetTimer = magnetDuration;
        createParticle(particleX, particleY, MAGNET_PARTICLE_COUNT, magnetParticleColor, MAGNET_PARTICLE_SPEED, 'burst');
        soundType = 'magnet';
        notificationText = "Magnet Activated!";
        totalItemsCaught++;
        break;
    case 'bad':
        lives--;
        score += penaltyValue;
        createParticle(particleX, particleY, BAD_HIT_PARTICLE_COUNT, badParticleColor, BAD_HIT_PARTICLE_SPEED, 'burst');
        soundType = 'bad';
        comboCount = 0;
        comboMultiplier = 1;
        break;
}
function handleItems() {
    itemTimer++;
    if (!isBonusRoundActive && Math.random() < BONUS_ROUND_TRIGGER_CHANCE && level >= MIN_LEVEL_FOR_BONUS) {
        startBonusRound();
    }
    if (itemTimer >= itemSpawnInterval) {
        items.push(createItem(isBonusRoundActive));
        itemTimer = 0;
    }
    let soundPlayedThisFrame = false; // Track if a sound was played
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.update();
        if (player && item.x < player.x + player.currentWidth && item.x + item.size > player.x && item.y + item.size > player.y && item.y < player.y + player.currentHeight) {
            let particleX = item.x + item.size / 2;
            let particleY = item.y + item.size / 2;
            let scoreToAdd = 0;
            let soundType = 'good';
            let notificationText = null;
            switch(item.type) {
                case 'superRare':
                    scoreToAdd = superRareItemValue;
                    createParticle(particleX, particleY, SUPER_RARE_PARTICLE_COUNT, superRareParticleColor, SUPER_RARE_PARTICLE_SPEED, 'burst');
                    soundType = 'superRare';
                    notificationText = "DIAMOND!";
                    totalItemsCaught++;
                    break;
                case 'golden':
                    scoreToAdd = goldenItemValue;
                    createParticle(particleX, particleY, GOLDEN_PARTICLE_COUNT, goldenParticleColor, GOLDEN_PARTICLE_SPEED, 'burst');
                    soundType = 'golden';
                    notificationText = "Golden Star!";
                    totalItemsCaught++;
                    goldenItemsCaught++;
                    break;
                case 'good':
                    scoreToAdd = itemValue;
                    createParticle(particleX, particleY, GOOD_PARTICLE_COUNT, goodParticleColor, GOOD_PARTICLE_SPEED, 'upward');
                    soundType = 'good';
                    totalItemsCaught++;
                    break;
                case 'life':
                    lives++;
                    createParticle(particleX, particleY, LIFE_PARTICLE_COUNT, lifeParticleColor, LIFE_PARTICLE_SPEED, 'upward');
                    soundType = 'life';
                    notificationText = "+1 Life!";
                    totalItemsCaught++;
                    break;
                case 'grow':
                    if (!isPlayerSmall) player.setSize('big');
                    createParticle(particleX, particleY, GROW_PARTICLE_COUNT, growParticleColor, GROW_PARTICLE_SPEED, 'burst');
                    soundType = 'grow';
                    notificationText = "Grew Big!";
                    totalItemsCaught++;
                    break;
                case 'shrink':
                    if (!isPlayerBig) player.setSize('small');
                    createParticle(particleX, particleY, SHRINK_PARTICLE_COUNT, shrinkParticleColor, SHRINK_PARTICLE_SPEED, 'burst');
                    soundType = 'shrink';
                    notificationText = "Shrunk Small!";
                    totalItemsCaught++;
                    break;
                case 'slowmo':
                    isSlowMo = true;
                    slowmoTimer = slowmoDuration;
                    items.forEach(item => item.speed *= slowmoSpeedMultiplier);
                    createParticle(particleX, particleY, SLOWMO_PARTICLE_COUNT, slowmoParticleColor, SLOWMO_PARTICLE_SPEED, 'burst');
                    soundType = 'slowmo';
                    notificationText = "Slow-Mo!";
                    totalItemsCaught++;
                    break;
                case 'magnet':
                    isMagnet = true;
                    magnetTimer = magnetDuration;
                    createParticle(particleX, particleY, MAGNET_PARTICLE_COUNT, magnetParticleColor, MAGNET_PARTICLE_SPEED, 'burst');
                    soundType = 'magnet';
                    notificationText = "Magnet Activated!";
                    totalItemsCaught++;
                    break;
                case 'bad':
                    lives--;
                    score += penaltyValue;
                    createParticle(particleX, particleY, BAD_HIT_PARTICLE_COUNT, badParticleColor, BAD_HIT_PARTICLE_SPEED, 'burst');
                    soundType = 'bad';
                    comboCount = 0;
                    comboMultiplier = 1;
                    break;
            }
            if (scoreToAdd > 0) {
                scoreToAdd *= comboMultiplier;
                score += scoreToAdd;
                comboCount++;
                if (comboCount >= comboThreshold) {
                    comboMultiplier = Math.min(maxComboMultiplier, Math.floor(comboCount / comboThreshold) + 1);
                    highestCombo = Math.max(highestCombo, comboMultiplier); // Update highest combo
                }
            } else if (item.type !== 'bad') {
                comboCount = 0;
                comboMultiplier = 1;
            }
            if (!soundPlayedThisFrame) {
                playSound(soundType);
                soundPlayedThisFrame = true;
            }
            if (notificationText) showItemNotification(notificationText);
            score = Math.max(0, score);
            scoreElement.textContent = `Score: ${score}`;
            livesElement.textContent = `Lives: ${lives}`;
            comboDisplayElement.textContent = comboMultiplier > 1 ? `x${comboMultiplier} Combo!` : '';
            comboDisplayElement.style.display = comboMultiplier > 1 ? 'block' : 'none';
            checkLevelUp();
            items.splice(i, 1);
            if (lives <= 0) {
                gameOver();
                return;
            }
        } else if (item.y > canvas.height) {
            if (item.isGood && !item.isGolden && !item.isSuperRare && item.type !== 'life' && item.type !== 'grow' && item.type !== 'shrink' && item.type !== 'slowmo' && item.type !== 'magnet') {
                lives -= missPenalty;
                livesElement.textContent = `Lives: ${lives}`;
                if (!soundPlayedThisFrame) {
                    playSound('miss');
                    soundPlayedThisFrame = true;
                }
            }
            comboCount = 0;
            comboMultiplier = 1;
            comboDisplayElement.style.display = 'none';
            items.splice(i, 1);
            if (lives <= 0) {
                gameOver();
                return;
            }
        }
    }
}
        function startBonusRound() { if (isBonusRoundActive) return; isBonusRoundActive = true; bonusRoundTimer = bonusRoundDuration; bonusDisplayElement.style.display = 'block'; console.log("BONUS ROUND STARTED!"); playSound('bonusStart'); items = []; // Clear existing items
             itemSpawnInterval = Math.max(MIN_ITEM_SPAWN_INTERVAL, baseItemSpawnInterval / 2); // Faster spawning
         }
        function updateBonusRound() { if (!isBonusRoundActive) return; bonusRoundTimer--; if (bonusRoundTimer <= 0) { isBonusRoundActive = false; bonusDisplayElement.style.display = 'none'; console.log("BONUS ROUND ENDED!"); itemSpawnInterval = baseItemSpawnInterval; // Restore normal spawn interval
             gameSpeed = baseGameSpeed; // Restore normal speed (if it was changed)
             } }
       function updateSlowMo() {
    if (!isSlowMo) return;
    slowmoTimer--;
    if (slowmoTimer <= 0) {
        isSlowMo = false;
        items.forEach(item => item.speed /= slowmoSpeedMultiplier);
        console.log("Slow-Mo Ended");
        showItemNotification("Slow-Mo Ended!");
    }
}

function updateMagnet() {
    if (!isMagnet) return;
    magnetTimer--;
    if (magnetTimer <= 0) {
        isMagnet = false;
        console.log("Magnet Ended");
        showItemNotification("Magnet Deactivated!");
    }
}
        function showItemNotification(text) { if (!itemNotificationElement) return; itemNotificationElement.textContent = text; itemNotificationElement.style.display = 'block'; clearTimeout(notificationTimeoutId); // Clear previous timeout
             // --- MODIFIED: Use constant for duration ---
             notificationTimeoutId = setTimeout(() => { itemNotificationElement.style.display = 'none'; }, ITEM_NOTIFICATION_DURATION); // Restart fadeout animation
             itemNotificationElement.style.animation = 'none'; itemNotificationElement.offsetHeight; itemNotificationElement.style.animation = ''; }
        function loadAchievements() {
    if (!playerName) return;
    try {
        const stored = localStorage.getItem(`${ACHIEVEMENTS_KEY}_${playerName}`);
        playerAchievements = stored ? JSON.parse(stored) : [];
        achievements.forEach(achievement => {
            achievement.unlocked = playerAchievements.includes(achievement.id);
        });
        console.log('Achievements loaded for', playerName, playerAchievements);
    } catch (e) {
        console.error('Error loading achievements:', e);
    }
}

function saveAchievements() {
    if (!playerName) return;
    try {
        const unlockedIds = achievements.filter(a => a.unlocked).map(a => a.id);
        localStorage.setItem(`${ACHIEVEMENTS_KEY}_${playerName}`, JSON.stringify(unlockedIds));
        playerAchievements = unlockedIds;
        console.log('Achievements saved for', playerName, unlockedIds);
    } catch (e) {
        console.error('Error saving achievements:', e);
    }
}

function checkAchievements() {
    let progressChanged = false;
    achievements.forEach(achievement => {
        const previousProgress = achievement.progress();
        if (!achievement.unlocked && achievement.condition()) {
            achievement.unlocked = true;
            showAchievementNotification(achievement.name);
            saveAchievements();
            console.log('Achievement unlocked:', achievement.name);
            progressChanged = true;
        } else if (!achievement.unlocked) {
            const currentProgress = achievement.progress();
            if (currentProgress !== previousProgress) {
                progressChanged = true;
            }
        }
    });
    // If progress changed and the modal is open, refresh it
    const modal = document.getElementById('achievements-modal');
    if (progressChanged && modal && modal.style.display === 'flex') {
        showAchievementsModal();
    }
}

function showAchievementNotification(achievementName) {
    const notification = document.getElementById('achievement-notification');
    if (notification) {
        notification.textContent = `Achievement: ${achievementName}!`;
        notification.style.display = 'block';
        notification.style.animation = 'none';
        notification.offsetHeight;
        notification.style.animation = '';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 2000); // 2 seconds
    }
}
function shareScore() {
    const gameUrl = 'https://aquamarine-dieffenbachia-ed23a6.netlify.app/'; // Replace with your actual game URL
    const shareMessage = `I scored ${score} on Bruin Catch! Can you beat it? ${gameUrl}`;
    const copiedNotification = document.getElementById('copied-notification');

    // Copy to clipboard
    navigator.clipboard.writeText(shareMessage).then(() => {
        console.log('Score shared to clipboard:', shareMessage);
        if (copiedNotification) {
            copiedNotification.style.display = 'block';
            copiedNotification.style.animation = 'none';
            copiedNotification.offsetHeight; // Trigger reflow
            copiedNotification.style.animation = '';
            setTimeout(() => {
                copiedNotification.style.display = 'none';
            }, 1500); // Matches fadeOutNotification duration
        }
    }).catch(err => {
        console.error('Failed to copy to clipboard:', err);
        alert('Failed to copy score. Share this: ' + shareMessage);
    });

    // Optional: Open Twitter/X share window
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareMessage)}`;
    window.open(twitterUrl, '_blank', 'width=600,height=400');
}
        // --- Drawing ---
        function drawBackground() { if (!themeColors || !ctx || !canvas) return; // Sky
             const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7); skyGradient.addColorStop(0, themeColors.sky1 || '#87CEEB'); skyGradient.addColorStop(1, themeColors.sky2 || '#ADD8E6'); ctx.fillStyle = skyGradient; ctx.fillRect(0, 0, canvas.width, canvas.height); // Ground
             if (typeof groundHeight !== 'undefined' && groundHeight > 0 && canvas.height > groundHeight) { const groundGradient = ctx.createLinearGradient(0, groundY, 0, canvas.height); // Use calculated groundY
                 groundGradient.addColorStop(0, themeColors.ground1 || '#8B4513'); groundGradient.addColorStop(1, themeColors.ground2 || '#A0522D'); ctx.fillStyle = groundGradient; ctx.fillRect(0, groundY, canvas.width, groundHeight); } }
        function drawGame() { if (canvas.style.visibility !== 'visible' || !ctx) { return; } ctx.clearRect(0, 0, canvas.width, canvas.height); drawBackground(); // --- MODIFIED: Draw items before player ---
             items.forEach(item => item.draw()); if (player) player.draw(); handleParticles(); }

        // --- Game Loop & State Management ---
function gameLoop() {
    if (isGameOver) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        return;
    }
    if (player) player.update();
    handleItems();
    if (isGameOver) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        return;
    }
    handleParticles();
    updateSlowMo();
    updateMagnet();
    updateBonusRound();
    passiveScoreTimer++;
    if (passiveScoreTimer >= passiveScoreInterval) {
        passiveScoreTimer = 0;
        let passiveScoreToAdd = 0;
        if (isPlayerSmall) passiveScoreToAdd = smallPassiveScore;
        else if (isPlayerBig) passiveScoreToAdd = bigPassiveScore;
        if (passiveScoreToAdd > 0) {
            score += passiveScoreToAdd;
            score = Math.max(0, score);
            scoreElement.textContent = `Score: ${score}`;
            checkLevelUp();
        }
    }
    checkAchievements();
    drawGame();
    animationFrameId = requestAnimationFrame(gameLoop);
}
  function gameOver() {
    if (isGameOver) {
        console.log("gameOver called but already over, skipping");
        return;
    }
    isGameOver = true;
    console.log("Game Over Triggered");
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    saveToLeaderboard();
    const safePlayerName = (playerName || "Bruin").replace(/</g, "<").replace(/>/g, ">");
    messageElement.innerHTML = `
        Game Over!<br>
        Player: ${safePlayerName}<br>
        Level: ${level} | Score: ${score}<br>
        Tap or Click to Play Again<br>
        <button id="share-score-button">Share Score</button>
    `;
    messageElement.style.display = 'block';
    gameContainer.style.cursor = 'pointer';
    playSound('gameOver');

    // Add event listeners for the share button
    const shareButton = document.getElementById('share-score-button');
    if (shareButton) {
        shareButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent triggering game restart
            shareScore();
        });
        shareButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            shareScore();
        });
    }
}

        function showNameInputScreen() { isGameOver = true; cancelAnimationFrame(animationFrameId); animationFrameId = null; nameInputOverlay.style.display = 'flex'; canvas.style.visibility = 'hidden'; uiOverlay.style.visibility = 'hidden'; messageElement.style.display = 'none'; levelUpMessageElement.style.display = 'none'; bonusDisplayElement.style.display = 'none'; // Hide bonus display too
             comboDisplayElement.style.display = 'none'; // Hide combo display
             loadRemoteLeaderboard(); // Load latest scores when showing screen
             playerNameInput.value = playerName; try { playerNameInput.focus(); } catch(e) {console.warn("Could not focus name input:", e)} }

        function initializeGame() { if (!isGameOver) { console.log("InitializeGame called but game not over. Ignoring."); return; } console.log("Initializing Game..."); initAudio(); // Ensure audio is ready
             isGameOver = false; score = 0; lives = 3; level = 1; baseGameSpeed = 2; // Reset speed/interval to base
             baseItemSpawnInterval = 95; gameSpeed = baseGameSpeed; itemSpawnInterval = baseItemSpawnInterval; items = []; particles = []; // Clear arrays
             itemTimer = 0; comboCount = 0; comboMultiplier = 1; isBonusRoundActive = false; bonusRoundTimer = 0; isPlayerBig = false; playerBigTimer = 0; isPlayerSmall = false; playerSmallTimer = 0; passiveScoreTimer = 0; // Reset UI elements
             scoreElement.textContent = `Score: ${score}`; livesElement.textContent = `Lives: ${lives}`; levelElement.textContent = `Level: ${level}`; const safePlayerName = (playerName || "Bruin").replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Sanitize
             playerNameDisplayElement.textContent = `Player: ${safePlayerName}`; comboDisplayElement.style.display = 'none'; bonusDisplayElement.style.display = 'none'; updateTopScoreDisplay(); // Update high score based on loaded leaderboard
             messageElement.style.display = 'none'; levelUpMessageElement.style.display = 'none'; gameContainer.style.cursor = 'grab'; canvas.style.visibility = 'visible'; uiOverlay.style.visibility = 'visible'; resizeCanvas(); // Ensure canvas is correct size before starting
             // Setup Player
             if (!player) { player = createPlayer(); } else { // Reset existing player object
                 player.x = canvas.width / 2 - basePlayerWidth / 2; player.dx = 0; player.setSize('normal'); // Reset size and position
             } // Start the loop
             cancelAnimationFrame(animationFrameId); // Ensure no previous loops running
             animationFrameId = requestAnimationFrame(gameLoop); console.log("Game Loop Started with ID:", animationFrameId); }

        // --- Event Listeners ---
        // Keyboard Controls

// --- Event Listeners ---
// Keyboard Controls
const handleRestart = (e) => {
    if (e.target.id === 'share-score-button') return; // Ignore share button clicks
    e.stopPropagation();
    if (isGameOver) {
        showNameInputScreen();
    }
};
messageElement.addEventListener('click', handleRestart);
messageElement.addEventListener('touchend', (e) => {
    if (e.target.id === 'share-score-button') return;
    e.preventDefault();
    handleRestart(e);
});

if (howToPlayButton && howToPlayModal && closeHowToPlayModalButton) {
    const handleHowToPlayClick = (eventType) => {
        console.log(`"How to Play" button event: ${eventType}. Fullscreen element:`, document.fullscreenElement ? document.fullscreenElement.id : "none");
        openHowToPlayModal();
    };

    howToPlayButton.addEventListener('click', () => handleHowToPlayClick('click'));
    howToPlayButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleHowToPlayClick('touchend');
    });

    closeHowToPlayModalButton.addEventListener('click', closeHowToPlayModal);
    closeHowToPlayModalButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        closeHowToPlayModal();
    });

    howToPlayModal.addEventListener('click', (event) => {
        if (event.target === howToPlayModal) {
            closeHowToPlayModal();
        }
    });

    console.log("Event listeners for 'howToPlayButton' attached.");
} else {
    if (!howToPlayButton) console.error("'howToPlayButton' not found during listener attachment.");
    if (!howToPlayModal) console.error("'howToPlayModal' not found during listener attachment.");
    if (!closeHowToPlayModalButton) console.error("'closeHowToPlayModalButton' not found during listener attachment.");
}

const achievementsButton = document.getElementById('achievements-button');
const achievementsModal = document.getElementById('achievements-modal');
const closeAchievementsButton = document.getElementById('close-achievements-button');

if (achievementsButton && achievementsModal && closeAchievementsButton) {
    achievementsButton.addEventListener('click', () => {
        showAchievementsModal();
    });
    achievementsButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        showAchievementsModal();
    });
    closeAchievementsButton.addEventListener('click', closeAchievementsModal);
    closeAchievementsButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        closeAchievementsModal();
    });
    achievementsModal.addEventListener('click', (e) => {
        if (e.target === achievementsModal) {
            closeAchievementsModal();
        }
    });
} else {
    console.warn("Achievements elements not found: button:", !!achievementsButton, "modal:", !!achievementsModal, "closeButton:", !!closeAchievementsButton);
}

if (fullscreenButton) {
    fullscreenButton.addEventListener('click', () => {
        console.log('Fullscreen button clicked');
        toggleFullScreen();
    });
    fullscreenButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        console.log('Fullscreen button touched');
        toggleFullScreen();
    });
} else {
    console.warn('Fullscreen button not found');
}

if (soundToggleButton) {
    soundToggleButton.addEventListener('click', toggleGlobalSound);
    soundToggleButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        toggleGlobalSound();
    });
}

window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'f') {
        try {
            gameContainer.focus();
        } catch (focusErr) {
            console.warn("Could not focus game container:", focusErr);
        }
        toggleFullScreen();
        e.preventDefault();
        return;
    }
    if (isGameOver && nameInputOverlay.style.display === 'flex' && (e.code === 'Space' || e.key === ' ' || e.key === 'Enter') && document.activeElement !== playerNameInput) {
        e.preventDefault();
        startGameButton.click();
        return;
    }
    if (isGameOver || !player) return;
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
        player.moveLeft();
    } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
        player.moveRight();
    }
});

window.addEventListener('keyup', (e) => {
    if (isGameOver || !player) return;
    if (((e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') && player.dx < 0) || ((e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') && player.dx > 0)) {
        player.stop();
    }
});

// Touch Controls
gameContainer.addEventListener('touchstart', (e) => {
    if (isGameOver) return;
    if (e.touches.length > 0 && player) {
        e.preventDefault();
        isDragging = true;
        touchStartX = e.touches[0].clientX;
        playerStartX = player.x;
        gameContainer.style.cursor = 'grabbing';
    }
}, { passive: false });

gameContainer.addEventListener('touchmove', (e) => {
    if (!isDragging || isGameOver || !player) return;
    e.preventDefault();
    if (e.touches.length > 0) {
        const touchCurrentX = e.touches[0].clientX;
        const deltaX = touchCurrentX - touchStartX;
        let newPlayerX = playerStartX + deltaX;
        newPlayerX = Math.max(0, Math.min(canvas.width - player.currentWidth, newPlayerX));
        player.x = newPlayerX;
    }
}, { passive: false });

const stopTouchDragging = (e) => {
    if (isDragging) {
        const targetIsMessage = messageElement.contains(e.target);
        if (isGameOver && targetIsMessage) {
            // Allow restart click/tap through
        }
        isDragging = false;
        touchStartX = null;
        playerStartX = null;
        gameContainer.style.cursor = 'grab';
    }
};
gameContainer.addEventListener('touchend', stopTouchDragging);
gameContainer.addEventListener('touchcancel', stopTouchDragging);

// Mouse Controls
gameContainer.addEventListener('mousedown', (e) => {
    if (isGameOver) return;
    if (player) {
        isDragging = true;
        touchStartX = e.clientX;
        playerStartX = player.x;
        gameContainer.style.cursor = 'grabbing';
    }
});

gameContainer.addEventListener('mousemove', (e) => {
    if (!isDragging || isGameOver || !player) return;
    const touchCurrentX = e.clientX;
    const deltaX = touchCurrentX - touchStartX;
    let newPlayerX = playerStartX + deltaX;
    newPlayerX = Math.max(0, Math.min(canvas.width - player.currentWidth, newPlayerX));
    player.x = newPlayerX;
});

const stopMouseDragging = () => {
    if (isDragging) {
        isDragging = false;
        touchStartX = null;
        playerStartX = null;
        gameContainer.style.cursor = 'grab';
    }
};
window.addEventListener('mouseup', stopMouseDragging);
gameContainer.addEventListener('mouseleave', stopMouseDragging);

// Start Game Button / Input Listeners
const handleStartGame = () => {
    playerName = playerNameInput.value.trim().substring(0, 15) || "Bruin";
    nameInputOverlay.style.display = 'none';
    initializeGame();
};
startGameButton.addEventListener('click', handleStartGame);
startGameButton.addEventListener('touchend', (e) => {
    e.preventDefault();
    handleStartGame();
});
playerNameInput.addEventListener('keyup', (e) => {
    if (e.key === 'Enter') {
        handleStartGame();
    }
});
playerNameInput.addEventListener('touchstart', (e) => {
    e.stopPropagation();
    playerNameInput.focus();
});
          // Restart Game Message Listeners

        // Fullscreen Toggle Function
         function toggleFullScreen() { try { if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) { console.log('Attempting to enter fullscreen on:', gameContainer); if (gameContainer.requestFullscreen) { gameContainer.requestFullscreen().catch(err => console.error('Fullscreen request failed:', err)); } else if (gameContainer.mozRequestFullScreen) { /* Firefox */ gameContainer.mozRequestFullScreen().catch(err => console.error('Moz fullscreen failed:', err)); } else if (gameContainer.webkitRequestFullscreen) { /* Chrome, Safari & Opera */ gameContainer.webkitRequestFullscreen().catch(err => console.error('Webkit fullscreen failed:', err)); } else if (gameContainer.msRequestFullscreen) { /* IE/Edge */ gameContainer.msRequestFullscreen().catch(err => console.error('MS fullscreen failed:', err)); } else { console.warn('Fullscreen API not supported by this browser.'); } } else { console.log('Attempting to exit fullscreen'); if (document.exitFullscreen) { document.exitFullscreen().catch(err => console.error('Exit fullscreen failed:', err)); } else if (document.mozCancelFullScreen) { /* Firefox */ document.mozCancelFullScreen().catch(err => console.error('Moz exit fullscreen failed:', err)); } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */ document.webkitExitFullscreen().catch(err => console.error('Webkit exit fullscreen failed:', err)); } else if (document.msExitFullscreen) { /* IE/Edge */ document.msExitFullscreen().catch(err => console.error('MS exit fullscreen failed:', err)); } else { console.warn('Exit Fullscreen API not supported by this browser.'); } } } catch (err) { console.error('Error during fullscreen toggle:', err); } }

        // --- Initial Setup ---
        window.addEventListener('resize', resizeCanvas);
      window.addEventListener('load', () => {
    loadRemoteLeaderboard();
    resizeCanvas();

    if (!howToPlayModal || !achievementsModal) {
        console.error("MODAL_DEBUG: CRITICAL - Modal element(s) not found on page load!");
        originalModalParent = document.body;
    } else {
        if (howToPlayModal.parentNode && howToPlayModal.parentNode !== gameContainer) {
            originalModalParent = howToPlayModal.parentNode;
        } else {
            originalModalParent = document.body;
        }
        if (achievementsModal.parentNode !== originalModalParent) {
            console.log("MODAL_DEBUG: Moving achievementsModal to originalModalParent on load:", originalModalParent.id || originalModalParent.tagName);
            originalModalParent.appendChild(achievementsModal);
        }
    }

    const savedSoundPreference = localStorage.getItem('bruinCatchSoundEnabled');
    if (savedSoundPreference !== null) {
        soundGloballyEnabled = savedSoundPreference === 'true';
    }
    updateSoundButtonIcon();
    showNameInputScreen();
});

        console.log("Script End Reached - Basic Test");

    </script>
</body>
</html>
