<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
Â  Â  <title>Bruin Catch (Unofficial)</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
Â  Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
Â  Â  <style>
Â  Â  Â  Â  /* --- CSS Styles (No changes needed here, but kept for completeness) --- */
Â  Â  Â  Â  html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #ADD8E6; font-family: 'Press Start 2P', cursive; }
body {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  justify-content: flex-start;
Â  Â  align-items: center;
Â  Â  min-height: 100vh; /* Or leave it commented out if you did that */
Â  Â  /* padding: 1rem; */ /* Try commenting this out */
Â  Â  padding: 0; /* Or try padding: 0; */
Â  Â  box-sizing: border-box;
Â  Â  touch-action: none;
Â  Â  transition: background-color 1s ease;
}Â  Â  Â 
Â  Â  Â  Â  .intro-text { font-size: 0.9em; color: #333; margin-bottom: 1rem; text-align: center; flex-shrink: 0; width: 100%; }
Â  Â  Â  Â  /* --- MODIFIED: Added outline: none for focus --- */
Â  Â  Â  Â  .game-container { border: 5px solid #2774AE; position: relative; overflow: hidden; width: 100%; max-width: 600px; aspect-ratio: 3 / 4; border-radius: 15px; box-shadow: 0 6px 12px rgba(0,0,0,0.15); background-color: #F2A900; cursor: grab; margin-top: 0; flex-shrink: 1; min-height: 0; outline: none; /* Remove focus outline */ }
Â  Â  Â  Â  canvas { display: block; width: 100%; height: 100%; visibility: hidden; background-color: transparent; }
Â  Â  Â  Â  /* Name Input Overlay */
Â  Â  Â  Â  #name-input-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.95); z-index: 30; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; text-align: center; color: #2774AE; }
Â  Â  Â  Â  Â /* Leaderboard Display */
Â  Â  Â  Â  Â #leaderboard-display { margin-top: 15px; font-size: 0.7em; text-align: left; width: 80%; max-width: 300px; border: 1px solid #ccc; padding: 10px; background-color: #f0f0f0; border-radius: 5px; }
Â  Â  Â  Â  Â #leaderboard-display h3 { margin: 0 0 5px 0; text-align: center; font-size: 1.1em; }
Â  Â  Â  Â  Â #leaderboard-list { list-style: none; padding: 0; margin: 0; }
Â  Â  Â  Â  Â #leaderboard-list li { margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
Â  Â  Â  Â  Â #leaderboard-list li span { display: inline-block; }
Â  Â  Â  Â  Â #leaderboard-list .rank { width: 20px; text-align: right; margin-right: 5px;}
Â  Â  Â  Â  Â #leaderboard-list .name { width: calc(50% - 25px); margin-right: 5px; overflow: hidden; text-overflow: ellipsis;}
Â  Â  Â  Â  Â #leaderboard-list .score { width: calc(30% - 5px); text-align: right; margin-right: 5px;}
Â  Â  Â  Â  Â #leaderboard-list .level { width: 20%; text-align: right; }
Â  Â  Â  Â  #name-input-overlay h2 { font-size: 1.3em; margin-bottom: 15px; }
Â  Â  Â  Â  #name-input-overlay p { font-size: 0.8em; line-height: 1.4; margin-bottom: 10px; /* Reduced margin */ max-width: 90%; }
Â  Â  Â  Â  /* --- ADDED: Style for fullscreen hint --- */
Â  Â  Â  Â  #name-input-overlay .fullscreen-hint { font-size: 0.65em; color: #555; margin-top: 5px; margin-bottom: 15px; }
Â  Â  Â  Â  #player-name-input { font-family: 'Press Start 2P', cursive; font-size: 1em; padding: 10px; margin-bottom: 20px; border: 2px solid #2774AE; border-radius: 5px; text-align: center; width: 80%; max-width: 250px; }
Â  Â  Â  Â  #start-game-button { font-family: 'Press Start 2P', cursive; font-size: 1em; padding: 12px 25px; background-color: #2774AE; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
Â  Â  Â  Â  #start-game-button:hover { background-color: #1E5A8C; }

Â  Â  Â  Â  /* In-Game UI */
Â  Â  Â  Â  .ui-overlay { position: absolute; top: 10px; left: 15px; right: 15px; display: flex; justify-content: space-between; align-items: flex-start; color: #ffffff; font-size: 1em; z-index: 10; pointer-events: none; visibility: hidden; }
Â  Â  Â  Â  .ui-left, .ui-center, .ui-right { display: flex; flex-direction: column; gap: 5px; }
Â  Â  Â  Â  .ui-left { align-items: flex-start; } .ui-center { align-items: center; } .ui-right { align-items: flex-end; }
Â  Â  Â  Â  .score, .lives, .level, .high-score-display, .high-level-display, .player-name-display, .combo-display, .bonus-display { background-color: rgba(39, 116, 174, 0.7); padding: 5px 10px; border-radius: 5px; white-space: nowrap; }
Â  Â  Â  Â  .level { font-size: 0.9em; }
Â  Â  Â  Â  .high-score-display, .high-level-display { font-size: 0.8em; background-color: rgba(0, 0, 0, 0.5); }
Â  Â  Â  Â  .player-name-display { position: absolute; bottom: 10px; left: 10px; font-size: 0.8em; background-color: rgba(0, 0, 0, 0.5); z-index: 10; }
Â  Â  Â  Â  .combo-display { position: absolute; bottom: 10px; right: 10px; font-size: 1.1em; color: #FFD700; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); z-index: 10; display: none; }
Â  Â  Â  Â  Â .bonus-display { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); font-size: 1.2em; color: #ff4500; background-color: rgba(255, 255, 0, 0.8); z-index: 15; display: none; padding: 5px 15px; animation: pulseBonus 1s infinite alternate; }
Â  Â  Â  Â  Â @keyframes pulseBonus { from { transform: translateX(-50%) scale(1); } to { transform: translateX(-50%) scale(1.1); } }
Â  Â  Â  Â  .message { /* Game Over Message */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #2774AE; font-size: 1.2em; text-align: center; display: none; background-color: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 10px; border: 3px solid #2774AE; z-index: 20; line-height: 1.5; max-width: 80%; box-shadow: 0 0 15px rgba(0,0,0,0.2); cursor: pointer; }
Â  Â  Â  Â  .level-up-message { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; font-size: 1.8em; text-align: center; display: none; z-index: 25; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); animation: fadeOutLevelUp 1.5s forwards; }
Â  Â  Â  Â  @keyframes fadeOutLevelUp { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); } }
Â  Â  Â  Â  /* Item Notification Style */
Â  Â  Â  Â  #item-notification { position: absolute; top: 60%; left: 50%; transform: translateX(-50%); font-size: 1.3em; color: white; padding: 8px 15px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.6); z-index: 22; display: none; text-align: center; text-shadow: 1px 1px 2px black; animation: fadeOutNotification 1.5s forwards; }
Â  Â  Â  Â  @keyframes fadeOutNotification { 0% { opacity: 1; transform: translateX(-50%) translateY(0); } 80% { opacity: 1; transform: translateX(-50%) translateY(0); } 100% { opacity: 0; transform: translateX(-50%) translateY(-20px); } }

Â  Â  Â  Â  /* Responsive */
Â  Â  Â  Â  Â @media (max-width: 600px) { .intro-text { font-size: 0.8em; } .ui-overlay { font-size: 0.9em; top: 8px; left: 12px; right: 12px; } .score, .lives, .level, .high-score-display, .high-level-display, .player-name-display, .combo-display, .bonus-display { padding: 4px 8px; } .combo-display { font-size: 1em; bottom: 8px; right: 8px;} .bonus-display { font-size: 1em; top: 45px; } .message { font-size: 1em; padding: 15px; } .level-up-message { font-size: 1.5em; } #name-input-overlay h2 { font-size: 1.1em; } #name-input-overlay p { font-size: 0.7em; } #name-input-overlay .fullscreen-hint { font-size: 0.6em; } #player-name-input { font-size: 0.9em; } #start-game-button { font-size: 0.9em; } .player-name-display { font-size: 0.7em; bottom: 8px; left: 8px;} #leaderboard-display { font-size: 0.6em; } #item-notification { font-size: 1.1em; } }
Â  Â  Â  Â  Â @media (max-width: 450px) { .intro-text { font-size: 0.7em; } .ui-overlay { font-size: 0.75em; left: 10px; right: 10px; } .level { font-size: 0.7em; } .high-score-display, .high-level-display { font-size: 0.65em; padding: 3px 6px;} .combo-display { font-size: 0.9em; } .bonus-display { font-size: 0.9em; } .message { font-size: 0.9em; padding: 10px; } .level-up-message { font-size: 1.2em; } .player-name-display { font-size: 0.65em; } #leaderboard-display { display: none; } #item-notification { font-size: 1em; } }
Â  Â  </style>
</head>
<body>
Â  Â  <div class="game-container" id="gameContainer" tabindex="0">
Â  Â  Â  Â  <div id="name-input-overlay">
Â  Â  Â  Â  Â  Â  <h2>Enter Player Name</h2>
Â  Â  Â  Â  Â  Â  <p>Move ğŸ» (Arrows/Drag) to catch falling items. Avoid items with red sparkles. Reach the highest level!</p>
Â  Â  Â  Â  Â  Â  <input type="text" id="player-name-input" placeholder="Bruin" maxlength="15">
Â  Â  Â  Â  Â  Â  <button id="start-game-button">Start Game</button>
Â  Â  Â  Â  Â  Â  <div id="leaderboard-display">
Â  Â  Â  Â  Â  Â  Â  Â  <h3>Leaderboard</h3>
Â  Â  Â  Â  Â  Â  Â  Â  <ol id="leaderboard-list"><li>Loading...</li></ol>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â </div>
Â  Â  Â  Â  <canvas id="gameCanvas"></canvas>
Â  Â  Â  Â  <div class="ui-overlay">
Â  Â  Â  Â  Â  Â  <div class="ui-left">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="score" class="score">Score: 0</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="high-score" class="high-score-display">Hi: 0 (Bruin)</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="ui-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â <div id="level" class="level">Level: 1</div>
Â  Â  Â  Â  Â  Â  Â  Â  Â <div id="high-level" class="high-level-display">Hi Lvl: 1</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div class="ui-right">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="lives" class="lives">Lives: 3</div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="player-name-display" class="player-name-display">Player: Bruin</div>
Â  Â  Â  Â  <div id="combo-display" class="combo-display"></div>
Â  Â  Â  Â  <div id="bonus-display" class="bonus-display">BONUS ROUND!</div>
Â  Â  Â  Â  <div id="message" class="message">Tap or Click to Start</div>
Â  Â  Â  Â  <div id="levelUpMessage" class="level-up-message">Level Up!</div>
Â  Â  Â  Â  <div id="item-notification"></div>
Â  Â  </div>

Â  Â  <script>
Â  Â  Â  Â  // --- Setup ---
Â  Â  Â  Â  const canvas = document.getElementById('gameCanvas');
Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  const gameContainer = document.getElementById('gameContainer');
Â  Â  Â  Â  const scoreElement = document.getElementById('score');
Â  Â  Â  Â  const livesElement = document.getElementById('lives');
Â  Â  Â  Â  const levelElement = document.getElementById('level');
Â  Â  Â  Â  const highScoreElement = document.getElementById('high-score');
Â  Â  Â  Â  const highLevelElement = document.getElementById('high-level');
Â  Â  Â  Â  const messageElement = document.getElementById('message');
Â  Â  Â  Â  const levelUpMessageElement = document.getElementById('levelUpMessage');
Â  Â  Â  Â  const nameInputOverlay = document.getElementById('name-input-overlay');
Â  Â  Â  Â  const playerNameInput = document.getElementById('player-name-input');
Â  Â  Â  Â  const startGameButton = document.getElementById('start-game-button');
Â  Â  Â  Â  const uiOverlay = document.querySelector('.ui-overlay');
Â  Â  Â  Â  const playerNameDisplayElement = document.getElementById('player-name-display');
Â  Â  Â  Â  const leaderboardListElement = document.getElementById('leaderboard-list');
Â  Â  Â  Â  const comboDisplayElement = document.getElementById('combo-display');
Â  Â  Â  Â  const bonusDisplayElement = document.getElementById('bonus-display');
Â  Â  Â  Â  const itemNotificationElement = document.getElementById('item-notification');

Â  Â  Â  Â  // --- Game Variables ---
Â  Â  Â  Â  let player; let playerName = "Bruin";
Â  Â  Â  Â  let items = []; let particles = [];
Â  Â  Â  Â  let score = 0; let leaderboard = [];
Â  Â  Â  Â  let lives = 3; let level = 1;
Â  Â  Â  Â  let baseGameSpeed = 2; let gameSpeed = baseGameSpeed;
Â  Â  Â  Â  let baseItemSpawnInterval = 95; let itemSpawnInterval = baseItemSpawnInterval;
Â  Â  Â  Â  let itemTimer = 0;
Â  Â  Â  Â  let isGameOver = true;
Â  Â  Â  Â  let animationFrameId = null;
Â  Â  Â  Â  let touchStartX = null; let playerStartX = null; let isDragging = false;
Â  Â  Â  Â  let comboCount = 0; const comboThreshold = 3;
Â  Â  Â  Â  let comboMultiplier = 1; const maxComboMultiplier = 5;
Â  Â  Â  Â  let isBonusRoundActive = false; let bonusRoundTimer = 0; const bonusRoundDuration = 600;
Â  Â  Â  Â  const bonusRoundChance = 0.0001;
Â  Â  Â  Â  let isPlayerBig = false; let playerBigTimer = 0; const playerBigDuration = 480;
Â  Â  Â  Â  let isPlayerSmall = false; let playerSmallTimer = 0; const playerSmallDuration = 480;
Â  Â  Â  Â  let passiveScoreTimer = 0; const passiveScoreInterval = 60;
Â  Â  Â  Â  const smallPassiveScore = 2; const bigPassiveScore = 1;
Â  Â  Â  Â  let notificationTimeoutId = null;

Â  Â  Â  Â  // --- Constants (unchanged) ---
Â  Â  Â  Â  const levelThresholds = [100, 250, 500, 800, 1200, 2000, 3000, 4000, 5500];
Â  Â  Â  Â  const levelSpeedIncrease = 0.5; const levelIntervalDecrease = 10;
Â  Â  Â  Â  const basePlayerWidth = 40; const basePlayerHeight = 40;
Â  Â  Â  Â  const playerEmoji = 'ğŸ»'; const playerSpeed = 9;
Â  Â  Â  Â  const playerAnimSpeed = 10;
Â  Â  Â  Â  const itemSize = 35;
Â  Â  Â  Â  const goodItems = ['ğŸ“', 'ğŸ“š', 'ğŸ€', 'ğŸ†']; const badItems = ['ğŸ—‘ï¸', 'ğŸ’¥', 'ğŸ’”'];
Â  Â  Â  Â  const goldenItemEmoji = 'ğŸŒŸ'; const superRareItemEmoji = 'ğŸ’';
Â  Â  Â  Â  const lifeItemEmoji = 'ğŸ’™'; const growItemEmoji = 'ğŸ„'; const shrinkItemEmoji = 'ğŸ’§';
Â  Â  Â  Â  const itemValue = 10; const goldenItemValue = 30; const superRareItemValue = 100;
Â  Â  Â  Â  const penaltyValue = 0; const missPenalty = 1;
Â  Â  Â  Â  const superRareSpeedMultiplier = 2.1;
Â  Â  Â  Â  const particleLifespan = 40;
Â  Â  Â  Â  const goodParticleColor = '#FFD700'; const badParticleColor = '#DC143C';
Â  Â  Â  Â  const goldenParticleColor = '#FFFF00'; const badItemSparkleColor = 'rgba(255, 0, 0, 0.8)';
Â  Â  Â  Â  const superRareParticleColor = '#FFFFFF'; const lifeParticleColor = '#00BFFF';
Â  Â  Â  Â  const growParticleColor = '#32CD32'; const shrinkParticleColor = '#8A2BE2';
Â  Â  Â  Â  const LEADERBOARD_KEY = 'bruinCatchLeaderboard_v2';
Â  Â  Â  Â  let themeColors = { sky1: '#87CEEB', sky2: '#ADD8E6', ground1: '#8B4513', ground2: '#A0522D', bodyBg: '#e0f2fe' };
Â  Â  Â  Â  const groundHeight = 20;
Â  Â  Â  Â  let groundY;

Â  Â  Â  Â  // --- Tone.js Setup (unchanged) ---
Â  Â  Â  Â  let jumpSynth, collectSynth, hurtSynth, levelUpSynth, bonusSynth, powerupSynth;
Â  Â  Â  Â  let soundsEnabled = false;
Â  Â  Â  Â  function initAudio() { if (soundsEnabled || typeof Tone === 'undefined') return; if (Tone.context.state !== 'running') { Tone.start().then(() => { if (soundsEnabled) return; jumpSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); collectSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(); hurtSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).toDestination(); levelUpSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.3 } }).toDestination(); bonusSynth = new Tone.Synth({ oscillator: { type: 'pulse', width: 0.4 }, envelope: { attack: 0.1, decay: 0.4, sustain: 0.2, release: 0.5 } }).toDestination(); powerupSynth = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -6, envelope: { attack: 0.02, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination(); soundsEnabled = true; console.log("Audio Initialized"); }).catch(e => { console.error("Audio init failed:", e); soundsEnabled = false; if (isGameOver) { messageElement.innerHTML = "Audio failed. Tap to retry."; messageElement.style.display = 'block'; } }); } else if (!soundsEnabled) { jumpSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); collectSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(); hurtSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).toDestination(); levelUpSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.3 } }).toDestination(); bonusSynth = new Tone.Synth({ oscillator: { type: 'pulse', width: 0.4 }, envelope: { attack: 0.1, decay: 0.4, sustain: 0.2, release: 0.5 } }).toDestination(); powerupSynth = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -6, envelope: { attack: 0.02, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination(); soundsEnabled = true; console.log("Audio Initialized (Context running)"); } }
Â  Â  Â  Â  function playSound(type, note = 'C4', duration = '8n') { if (!soundsEnabled) return; try { const now = Tone.now(); if (type === 'good' && collectSynth) collectSynth.triggerAttackRelease('C5', '16n', now); else if (type === 'golden' && collectSynth) collectSynth.triggerAttackRelease('E5', '16n', now + 0.01); else if (type === 'superRare' && collectSynth) collectSynth.triggerAttackRelease('G5', '8n', now + 0.02); else if (type === 'bad' && hurtSynth) hurtSynth.triggerAttackRelease('C3', '8n', now); else if (type === 'miss' && hurtSynth) hurtSynth.triggerAttackRelease('A2', '16n', now); else if (type === 'life' && powerupSynth) powerupSynth.triggerAttackRelease('A4', '8n', now); else if (type === 'grow' && powerupSynth) powerupSynth.triggerAttackRelease('E4', '8n', now); else if (type === 'shrink' && powerupSynth) powerupSynth.triggerAttackRelease('C4', '8n', now); else if (type === 'levelUp' && levelUpSynth) levelUpSynth.triggerAttackRelease('G4', '4n', now); else if (type === 'bonusStart' && bonusSynth) bonusSynth.triggerAttackRelease('C5', '2n', now); else if (type === 'gameOver' && hurtSynth) hurtSynth.triggerAttackRelease('F2', '1n', now); } catch (e) { console.error("Sound playback error:", e); } }

Â  Â  Â  Â  // --- Leaderboard Handling (unchanged) ---
Â  Â  Â  Â  function loadLeaderboard() { try { const storedData = localStorage.getItem(LEADERBOARD_KEY); leaderboard = storedData ? JSON.parse(storedData) : []; if (!Array.isArray(leaderboard)) leaderboard = []; leaderboard.sort((a, b) => b.score - a.score || b.level - a.level); } catch (e) { console.error("LS Error (Load Leaderboard):", e); leaderboard = []; } finally { displayLeaderboard(); updateTopScoreDisplay(); } }
function saveToLeaderboard() {
Â  Â  if (!playerName) {
Â  Â  Â  Â  playerName = "Bruin"; // Fallback if no name is entered
Â  Â  }
Â  Â  const scoreData = { name: playerName, score: score, level: level };

Â  Â  fetch('https://aquamarine-dieffenbachia-ed23a6.netlify.app/.netlify/functions/save-score', {
Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  headers: {
Â  Â  Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  Â  },
Â  Â  Â  Â  body: JSON.stringify(scoreData),
Â  Â  })
Â  Â  .then(response => response.json())
Â  Â  .then(data => {
Â  Â  Â  Â  console.log('Score saved:', data);
Â  Â  Â Â  loadRemoteLeaderboard(); // Fetch the updated leaderboard from the server
Â  Â  })
Â  Â  .catch(error => {
Â  Â  Â  Â  console.error('Error saving score:', error);
Â  Â  Â  Â  // Optionally, you could still save locally as a fallback if the server is down
Â  Â  Â  Â  console.warn('Falling back to local storage for saving score.');
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const currentEntry = { name: playerName, score: score, level: level };
Â  Â  Â  Â  Â  Â  let playerIndex = leaderboard.findIndex(entry => entry.name === playerName);
Â  Â  Â  Â  Â  Â  if (playerIndex !== -1) {
Â  Â  Â  Â  Â  Â  Â  Â  if (score > leaderboard[playerIndex].score || (score === leaderboard[playerIndex].score && level > leaderboard[playerIndex].level)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  leaderboard[playerIndex] = currentEntry;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  leaderboard.push(currentEntry);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  leaderboard.sort((a, b) => b.score - a.score || b.level - a.level);
Â  Â  Â  Â  Â  Â  leaderboard = leaderboard.slice(0, 5);
Â  Â  Â  Â  Â  Â  localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
Â  Â  Â  Â  Â  Â  displayLeaderboard();
Â  Â  Â  Â  Â  Â  updateTopScoreDisplay();
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("LS Error (Save Leaderboard - Fallback):", e);
Â  Â  Â  Â  }
Â  Â  });
}Â  Â  Â  Â  function displayLeaderboard() { if (!leaderboardListElement) return; leaderboardListElement.innerHTML = ''; if (leaderboard.length === 0) { leaderboardListElement.innerHTML = '<li>No scores yet!</li>'; return; } leaderboard.forEach((entry, index) => { const li = document.createElement('li'); const safeName = entry.name.replace(/</g, "&lt;").replace(/>/g, "&gt;"); li.innerHTML = `<span class="rank">${index + 1}.</span><span class="name">${safeName}</span><span class="score">${entry.score}</span><span class="level">(L${entry.level})</span>`; leaderboardListElement.appendChild(li); }); }
Â  Â  Â  Â  function updateTopScoreDisplay() { if (leaderboard.length > 0) { const topEntry = leaderboard[0]; const safeName = topEntry.name.replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(highScoreElement) highScoreElement.textContent = `Hi: ${topEntry.score} (${safeName})`; if(highLevelElement) highLevelElement.textContent = `Hi Lvl: ${topEntry.level}`; } else { if(highScoreElement) highScoreElement.textContent = `Hi: 0 (Bruin)`; if(highLevelElement) highLevelElement.textContent = `Hi Lvl: 1`; } }
Â  Â  Â  Â  Â  Â  Â  Â function resetLeaderboard() {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  localStorage.removeItem(LEADERBOARD_KEY);
Â  Â  Â  Â  Â  Â  Â  Â  leaderboard = [];
Â  Â  Â  Â  Â  Â  Â  Â  displayLeaderboard();
Â  Â  Â  Â  Â  Â  Â  Â  updateTopScoreDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  console.log("Leaderboard has been reset.");
Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("Error resetting leaderboard:", e);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- Resize Canvas (unchanged) ---
Â  Â  Â  Â  function resizeCanvas() { canvas.width = gameContainer.clientWidth; canvas.height = gameContainer.clientHeight; groundY = canvas.height - groundHeight - basePlayerHeight; if (player) { player.y = canvas.height - player.currentHeight - 10; player.x = Math.max(0, Math.min(canvas.width - player.currentWidth, player.x)); } if (!isGameOver) { drawGame(); } }

Â  Â  Â  Â  // --- Particle System (unchanged) ---
Â  Â  Â  Â  function createParticle(x, y, count = 8, color = goodParticleColor, speed = 3, type = 'burst') { for (let i = 0; i < count; i++) { let vx, vy; if (type === 'burst') { vx = (Math.random() - 0.5) * speed * 1.5; vy = (Math.random() - 0.5) * speed * 1.5; } else if (type === 'upward') { vx = (Math.random() - 0.5) * speed * 0.8; vy = (Math.random() * -speed) - 1; } else if (type === 'radiate') { const angle = Math.random() * Math.PI * 2; const currentSpeed = Math.random() * speed * 0.5 + 0.2; vx = Math.cos(angle) * currentSpeed; vy = Math.sin(angle) * currentSpeed; } else { vx = (Math.random() - 0.5) * speed * 1.5; vy = (Math.random() * -speed) - 1; } particles.push({ x: x, y: y, vx: vx, vy: vy, life: particleLifespan + Math.random() * 20, size: Math.random() * 4 + 2, color: color, alpha: 1.0 }); } }
Â  Â  Â  Â  function handleParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life--; p.alpha = Math.max(0, p.life / particleLifespan); if (p.life <= 0) { particles.splice(i, 1); } else { ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size); ctx.globalAlpha = 1.0; } } }

Â  Â  Â  Â  // --- Object Creation (unchanged) ---
Â  Â  Â  Â  function createPlayer() { playerWidth = basePlayerWidth; playerHeight = basePlayerHeight; return { x: canvas.width / 2 - playerWidth / 2, y: canvas.height - playerHeight - 10, baseWidth: basePlayerWidth, baseHeight: basePlayerHeight, currentWidth: playerWidth, currentHeight: playerHeight, emoji: playerEmoji, dx: 0, animFrame: 0, update: function() { let moved = false; if (this.dx !== 0) { this.x += this.dx; moved = true; this.animFrame = (this.animFrame + 1) % (playerAnimSpeed * 2); } else { this.animFrame = 0; } if (this.x < 0) this.x = 0; if (this.x > canvas.width - this.currentWidth) this.x = canvas.width - this.currentWidth; if (isPlayerBig) { playerBigTimer--; if (playerBigTimer <= 0) this.setSize('normal'); } if (isPlayerSmall) { playerSmallTimer--; if (playerSmallTimer <= 0) this.setSize('normal'); } }, draw: function() { ctx.save(); const scaleFactor = (this.dx !== 0 && this.animFrame < playerAnimSpeed) ? 1.05 : 1.0; ctx.translate(this.x + this.currentWidth / 2, this.y + this.currentHeight / 2); ctx.scale(scaleFactor, scaleFactor); ctx.font = `${this.currentHeight}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, 0, 0); ctx.restore(); }, setSize: function(sizeType) { isPlayerBig = false; isPlayerSmall = false; playerBigTimer = 0; playerSmallTimer = 0; if (sizeType === 'big') { this.currentWidth = this.baseWidth * 1.5; this.currentHeight = this.baseHeight * 1.5; isPlayerBig = true; playerBigTimer = playerBigDuration; } else if (sizeType === 'small') { this.currentWidth = this.baseWidth * 0.6; this.currentHeight = this.baseHeight * 0.6; isPlayerSmall = true; playerSmallTimer = playerSmallDuration; } else { this.currentWidth = this.baseWidth; this.currentHeight = this.baseHeight; } this.y = canvas.height - this.currentHeight - 10; this.x = Math.max(0, Math.min(canvas.width - this.currentWidth, this.x)); playerWidth = this.currentWidth; playerHeight = this.currentHeight; }, moveLeft: function() { this.dx = -playerSpeed; }, moveRight: function() { this.dx = playerSpeed; }, stop: function() { this.dx = 0; this.animFrame = 0; } }; }
Â  Â  Â  Â  function createItem(bonusActive = false) { let emoji; let type; let isGood = true; let isGolden = false; let isSuperRare = false; let itemSpeed = gameSpeed + Math.random() * 1.5; const rand = Math.random(); if (bonusActive) { if (rand < 0.07) { emoji = superRareItemEmoji; type = 'superRare'; isSuperRare = true; itemSpeed = gameSpeed * superRareSpeedMultiplier + Math.random() * 2; } else if (rand < 0.15) { emoji = goldenItemEmoji; type = 'golden'; isGolden = true; } else { emoji = goodItems[Math.floor(Math.random() * goodItems.length)]; type = 'good'; } } else { if (rand < 0.01) { emoji = superRareItemEmoji; type = 'superRare'; isSuperRare = true; itemSpeed = gameSpeed * superRareSpeedMultiplier + Math.random() * 2; } else if (rand < 0.02) { emoji = goldenItemEmoji; type = 'golden'; isGolden = true; } else if (rand < 0.035) { emoji = lifeItemEmoji; type = 'life'; } else if (rand < 0.040) { emoji = growItemEmoji; type = 'grow'; } else if (rand < 0.040) { emoji = shrinkItemEmoji; type = 'shrink'; } else if (rand < 0.305) { emoji = badItems[Math.floor(Math.random() * badItems.length)]; type = 'bad'; isGood = false; } else { emoji = goodItems[Math.floor(Math.random() * goodItems.length)]; type = 'good'; } } return { x: Math.random() * (canvas.width - itemSize), y: -itemSize, size: itemSize, emoji: emoji, type: type, isGood: isGood, isGolden: isGolden, isSuperRare: isSuperRare, speed: itemSpeed, update: function() { this.y += this.speed; }, draw: function() { ctx.save(); ctx.font = `${this.size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; if (this.type === 'bad' && Math.random() < 0.3) { createParticle(this.x + this.size / 2, this.y + this.size / 2, 1, badItemSparkleColor, 1.8, 'radiate'); } else if (this.isGolden) { ctx.shadowColor = 'rgba(255, 223, 0, 0.8)'; ctx.shadowBlur = 10; } else if (this.isSuperRare) { ctx.shadowColor = 'rgba(200, 200, 255, 0.9)'; ctx.shadowBlur = 12; if (Math.random() < 0.4) { createParticle(this.x + this.size / 2, this.y + this.size / 2, 1, superRareParticleColor, 1.2, 'radiate'); } } else if (this.type === 'life') { ctx.shadowColor = 'rgba(0, 191, 255, 0.7)'; ctx.shadowBlur = 8;} else if (this.type === 'grow') { ctx.shadowColor = 'rgba(50, 205, 50, 0.7)'; ctx.shadowBlur = 8;} else if (this.type === 'shrink') { ctx.shadowColor = 'rgba(138, 43, 226, 0.7)'; ctx.shadowBlur = 8;} ctx.fillText(this.emoji, this.x + this.size / 2, this.y + this.size / 2); ctx.restore(); } }; }

Â  Â  Â  Â  // --- Game Logic (unchanged) ---
Â  Â  Â  Â  function checkLevelUp() { if (level - 1 < levelThresholds.length && score >= levelThresholds[level - 1]) { level++; baseGameSpeed += levelSpeedIncrease; baseItemSpawnInterval = Math.max(20, baseItemSpawnInterval - levelIntervalDecrease); levelElement.textContent = `Level: ${level}`; console.log(`Level Up! Level: ${level}, Speed: ${baseGameSpeed.toFixed(2)}, Interval: ${baseItemSpawnInterval}`); levelUpMessageElement.textContent = `Level ${level}!`; levelUpMessageElement.style.display = 'block'; levelUpMessageElement.style.animation = 'none'; levelUpMessageElement.offsetHeight; levelUpMessageElement.style.animation = ''; playSound('levelUp'); } gameSpeed = baseGameSpeed; itemSpawnInterval = baseItemSpawnInterval; }
Â  Â  Â  Â  function handleItems() { itemTimer++; if (!isBonusRoundActive && Math.random() < bonusRoundChance && level >= 3) { startBonusRound(); } if (itemTimer >= itemSpawnInterval) { items.push(createItem(isBonusRoundActive)); itemTimer = 0; } for (let i = items.length - 1; i >= 0; i--) { const item = items[i]; item.update(); item.draw(); if ( player && item.x < player.x + player.currentWidth && item.x + item.size > player.x && item.y < player.y + player.currentHeight && item.y + item.size > player.y ) { let particleX = item.x + item.size / 2; let particleY = item.y + item.size / 2; let scoreToAdd = 0; let soundType = 'good'; let notificationText = null; switch(item.type) { case 'superRare': scoreToAdd = superRareItemValue; createParticle(particleX, particleY, 40, superRareParticleColor, 6, 'burst'); soundType = 'superRare'; notificationText = "DIAMOND!"; break; case 'golden': scoreToAdd = goldenItemValue; createParticle(particleX, particleY, 25, goldenParticleColor, 5, 'burst'); soundType = 'golden'; notificationText = "Golden Star!"; break; case 'good': scoreToAdd = itemValue; createParticle(particleX, particleY, 8, goodParticleColor, 3, 'upward'); soundType = 'good'; break; case 'life': lives++; createParticle(particleX, particleY, 15, lifeParticleColor, 4, 'upward'); soundType = 'life'; notificationText = "+1 Life!"; break; case 'grow': if (!isPlayerSmall) player.setSize('big'); createParticle(particleX, particleY, 15, growParticleColor, 4, 'burst'); soundType = 'grow'; notificationText = "Grew Big!"; break; case 'shrink': if (!isPlayerBig) player.setSize('small'); createParticle(particleX, particleY, 15, shrinkParticleColor, 4, 'burst'); soundType = 'shrink'; notificationText = "Shrunk Small!"; break; case 'bad': lives--; createParticle(particleX, particleY, 15, badParticleColor, 4, 'burst'); soundType = 'bad'; comboCount = 0; comboMultiplier = 1; break; } if (scoreToAdd > 0) { scoreToAdd *= comboMultiplier; score += scoreToAdd; comboCount++; if (comboCount >= comboThreshold) { comboMultiplier = Math.min(maxComboMultiplier, Math.floor(comboCount / comboThreshold) + 1); } } else if (item.type !== 'bad') { comboCount = 0; comboMultiplier = 1; } playSound(soundType); if (notificationText) showItemNotification(notificationText); score = Math.max(0, score); scoreElement.textContent = `Score: ${score}`; livesElement.textContent = `Lives: ${lives}`; comboDisplayElement.textContent = comboMultiplier > 1 ? `x${comboMultiplier} Combo!` : ''; comboDisplayElement.style.display = comboMultiplier > 1 ? 'block' : 'none'; checkLevelUp(); items.splice(i, 1); if (lives <= 0) { gameOver(); return; } } else if (item.y > canvas.height) { if (item.isGood && !item.isGolden && !item.isSuperRare) { lives -= missPenalty; livesElement.textContent = `Lives: ${lives}`; playSound('miss'); } comboCount = 0; comboMultiplier = 1; comboDisplayElement.style.display = 'none'; items.splice(i, 1); if (lives <= 0) { gameOver(); return; } } } }
Â  Â  Â  Â  function startBonusRound() { if (isBonusRoundActive) return; isBonusRoundActive = true; bonusRoundTimer = bonusRoundDuration; bonusDisplayElement.style.display = 'block'; console.log("BONUS ROUND STARTED!"); playSound('bonusStart'); items = []; }
Â  Â  Â  Â  function updateBonusRound() { if (!isBonusRoundActive) return; bonusRoundTimer--; if (bonusRoundTimer <= 0) { isBonusRoundActive = false; bonusDisplayElement.style.display = 'none'; console.log("BONUS ROUND ENDED!"); } }
Â  Â  Â  Â  function showItemNotification(text) { if (!itemNotificationElement) return; itemNotificationElement.textContent = text; itemNotificationElement.style.display = 'block'; clearTimeout(notificationTimeoutId); notificationTimeoutId = setTimeout(() => { itemNotificationElement.style.display = 'none'; }, 1500); itemNotificationElement.style.animation = 'none'; itemNotificationElement.offsetHeight; itemNotificationElement.style.animation = ''; }

Â  Â  Â  Â  // --- Drawing (unchanged) ---
Â  Â  Â  Â  function drawBackground() { if (!themeColors || !ctx || !canvas) return; const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7); skyGradient.addColorStop(0, themeColors.sky1 || '#87CEEB'); skyGradient.addColorStop(1, themeColors.sky2 || '#ADD8E6'); ctx.fillStyle = skyGradient; ctx.fillRect(0, 0, canvas.width, canvas.height); if (typeof groundHeight !== 'undefined' && groundHeight > 0 && canvas.height > groundHeight) { const groundGradient = ctx.createLinearGradient(0, canvas.height - groundHeight, 0, canvas.height); groundGradient.addColorStop(0, themeColors.ground1 || '#8B4513'); groundGradient.addColorStop(1, themeColors.ground2 || '#A0522D'); ctx.fillStyle = groundGradient; ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight); } }
Â  Â  Â  Â  function drawGame() { if (canvas.style.visibility !== 'visible' || !ctx) { return; } ctx.clearRect(0, 0, canvas.width, canvas.height); drawBackground(); items.forEach(item => item.draw()); if (player) player.draw(); handleParticles(); }

Â  Â  Â  Â  // --- Game Loop & State Management (unchanged) ---
Â  Â  Â  Â  function gameLoop() { if (isGameOver) { cancelAnimationFrame(animationFrameId); animationFrameId = null; return; } if (player) player.update(); handleItems(); if (isGameOver) { cancelAnimationFrame(animationFrameId); animationFrameId = null; return; } handleParticles(); updateBonusRound(); passiveScoreTimer++; if (passiveScoreTimer >= passiveScoreInterval) { passiveScoreTimer = 0; let passiveScoreToAdd = 0; if (isPlayerSmall) { passiveScoreToAdd = smallPassiveScore; } else if (isPlayerBig) { passiveScoreToAdd = bigPassiveScore; } if (passiveScoreToAdd > 0) { score += passiveScoreToAdd; score = Math.max(0, score); scoreElement.textContent = `Score: ${score}`; checkLevelUp(); } } drawGame(); animationFrameId = requestAnimationFrame(gameLoop); }
Â  Â  Â  Â  function gameOver() { if (isGameOver) return; isGameOver = true; console.log("Game Over Triggered"); cancelAnimationFrame(animationFrameId); animationFrameId = null; saveToLeaderboard(); messageElement.innerHTML = `Game Over!<br>Level: ${level} | Score: ${score}<br>Tap or Click to Play Again`; messageElement.style.display = 'block'; gameContainer.style.cursor = 'pointer'; playSound('gameOver'); }
Â  Â  Â  Â  function loadRemoteLeaderboard() {
Â  Â  fetch('https://aquamarine-dieffenbachia-ed23a6.netlify.app/.netlify/functions/get-scores')
Â  Â  Â  Â  .then(response => response.json())
Â  Â  Â  Â  .then(data => {
Â  Â  Â  Â  Â  Â  leaderboard = data;
Â  Â  Â  Â  Â  Â  displayLeaderboard();
Â  Â  Â  Â  Â  Â  updateTopScoreDisplay();
Â  Â  Â  Â  })
Â  Â  Â  Â  .catch(error => {
Â  Â  Â  Â  Â  Â  console.error('Error fetching leaderboard:', error);
Â  Â  Â  Â  Â  Â  // Optionally, load local leaderboard as a fallback if the server is down
Â  Â  Â  Â  Â  Â  console.warn('Falling back to local storage for leaderboard.');
Â  Â  Â  Â  Â  Â  loadLeaderboard();
Â  Â  Â  Â  });
}
Â  Â  Â  Â  function showNameInputScreen() { isGameOver = true; cancelAnimationFrame(animationFrameId); animationFrameId = null; nameInputOverlay.style.display = 'flex'; canvas.style.visibility = 'hidden'; uiOverlay.style.visibility = 'hidden'; messageElement.style.display = 'none'; levelUpMessageElement.style.display = 'none'; loadLeaderboard(); playerNameInput.value = playerName; try { playerNameInput.focus(); } catch(e) {} }
Â  Â  Â  Â  function initializeGame() { if (!isGameOver) { console.log("InitializeGame called but game not over. Ignoring."); return; } console.log("Initializing Game..."); initAudio(); isGameOver = false; score = 0; lives = 3; level = 1; baseGameSpeed = 2; baseItemSpawnInterval = 95; gameSpeed = baseGameSpeed; itemSpawnInterval = baseItemSpawnInterval; items = []; particles = []; itemTimer = 0; comboCount = 0; comboMultiplier = 1; isBonusRoundActive = false; bonusRoundTimer = 0; isPlayerBig = false; playerBigTimer = 0; isPlayerSmall = false; playerSmallTimer = 0; passiveScoreTimer = 0; scoreElement.textContent = `Score: ${score}`; livesElement.textContent = `Lives: ${lives}`; levelElement.textContent = `Level: ${level}`; playerNameDisplayElement.textContent = `Player: ${playerName}`; comboDisplayElement.style.display = 'none'; bonusDisplayElement.style.display = 'none'; updateTopScoreDisplay(); messageElement.style.display = 'none'; levelUpMessageElement.style.display = 'none'; gameContainer.style.cursor = 'grab'; canvas.style.visibility = 'visible'; uiOverlay.style.visibility = 'visible'; resizeCanvas(); if (!player) { player = createPlayer(); } else { player.x = canvas.width / 2 - basePlayerWidth / 2; player.dx = 0; player.setSize('normal'); } cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(gameLoop); console.log("Game Loop Started with ID:", animationFrameId); }

Â  Â  Â  Â  // --- Event Listeners ---
Â  Â  Â  Â  // Keyboard Controls
Â  Â   Â  Â  window.addEventListener('keydown', (e) => {
Â  Â  Â  Â  Â  Â  // --- MODIFIED: Focus container before toggle ---
Â  Â  Â  Â  Â  Â  if (e.key.toLowerCase() === 'f') {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameContainer.focus(); // Attempt to focus the container first
Â  Â  Â  Â  Â  Â  Â  Â  } catch(focusErr) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn("Could not focus game container:", focusErr);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  toggleFullScreen(); // Then attempt fullscreen
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault(); // Prevent default browser action for 'f'
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Existing keydown logic
Â  Â  Â  Â  Â  Â  if (isGameOver && nameInputOverlay.style.display === 'flex' && (e.code === 'Space' || e.key === ' ' || e.key === 'Enter') && document.activeElement !== playerNameInput) {
Â  Â  Â  Â  Â  Â  Â  Â  startGameButton.click();
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (isGameOver || !player) return;

Â  Â  Â  Â  Â  Â  if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
Â  Â  Â  Â  Â  Â  Â  Â  player.moveLeft();
Â  Â  Â  Â  Â  Â  } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
Â  Â  Â  Â  Â  Â  Â  Â  player.moveRight();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  window.addEventListener('keyup', (e) => { if (isGameOver || !player) return; if (((e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') && player.dx < 0) || ((e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') && player.dx > 0)) { player.stop(); } });
Â  Â  Â  Â  // Touch Controls (unchanged)
Â  Â  Â  Â  gameContainer.addEventListener('touchstart', (e) => { e.preventDefault(); if (isGameOver) return; if (e.touches.length > 0 && player) { isDragging = true; touchStartX = e.touches[0].clientX; playerStartX = player.x; gameContainer.style.cursor = 'grabbing'; } }, { passive: false });
Â  Â  Â  Â  gameContainer.addEventListener('touchmove', (e) => { e.preventDefault(); if (!isDragging || isGameOver || !player) return; if (e.touches.length > 0) { const touchCurrentX = e.touches[0].clientX; const deltaX = touchCurrentX - touchStartX; let newPlayerX = playerStartX + deltaX; newPlayerX = Math.max(0, Math.min(canvas.width - player.currentWidth, newPlayerX)); player.x = newPlayerX; } }, { passive: false });
Â  Â  Â  Â  const stopTouchDragging = () => { if (isDragging) { isDragging = false; touchStartX = null; playerStartX = null; gameContainer.style.cursor = 'grab'; } };
Â  Â  Â  Â  gameContainer.addEventListener('touchend', stopTouchDragging);
Â  Â  Â  Â  gameContainer.addEventListener('touchcancel', stopTouchDragging);
Â  Â  Â  Â  // Mouse Controls (unchanged)
Â  Â  Â  Â  gameContainer.addEventListener('mousedown', (e) => { if (isGameOver) return; if (player) { isDragging = true; touchStartX = e.clientX; playerStartX = player.x; gameContainer.style.cursor = 'grabbing'; } });
Â  Â  Â  Â  gameContainer.addEventListener('mousemove', (e) => { if (!isDragging || isGameOver || !player) return; const touchCurrentX = e.clientX; const deltaX = touchCurrentX - touchStartX; let newPlayerX = playerStartX + deltaX; newPlayerX = Math.max(0, Math.min(canvas.width - player.currentWidth, newPlayerX)); player.x = newPlayerX; });
Â  Â  Â  Â  const stopMouseDragging = () => { if (isDragging) { isDragging = false; touchStartX = null; playerStartX = null; gameContainer.style.cursor = 'grab'; } };
Â  Â  Â  Â  window.addEventListener('mouseup', stopMouseDragging);
Â  Â  Â  Â  gameContainer.addEventListener('mouseleave', stopMouseDragging);
Â  Â  Â  Â  Â // Start Game Button Listener (unchanged)
Â  Â  Â  Â  Â startGameButton.addEventListener('click', () => { playerName = playerNameInput.value.trim().substring(0, 15) || "Bruin"; nameInputOverlay.style.display = 'none'; initializeGame(); });
Â  Â  Â  Â  startGameButton.addEventListener('touchstart', () => { playerName = playerNameInput.value.trim().substring(0, 15) || "Bruin"; nameInputOverlay.style.display = 'none'; initializeGame(); });
Â  Â  Â  Â  Â // Allow Enter key in input field to start game (unchanged)
Â  Â  Â  Â  Â playerNameInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') { startGameButton.click(); } });
Â  Â  Â  Â  playerNameInput.addEventListener('touchstart', (e) => {
Â  // On touchstart, focus the input to bring up the keyboard if it's not already visible
Â  playerNameInput.focus();
});
Â  Â  Â  Â  // Allow restarting by clicking game over message (unchanged)
Â  Â  Â  Â  Â messageElement.addEventListener('click', (e) => { e.stopPropagation(); if (isGameOver) { showNameInputScreen(); } });
Â  Â  Â  Â  messageElement.addEventListener('touchstart', (e) => { e.stopPropagation(); if (isGameOver) { showNameInputScreen(); } });

Â  Â  Â  Â  // Fullscreen Toggle Function (unchanged, but added more logging)
Â  Â  Â  Â  function toggleFullScreen() {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log('Attempting to enter fullscreen on:', gameContainer);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (gameContainer.requestFullscreen) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameContainer.requestFullscreen().catch(err => console.error('Fullscreen request failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (gameContainer.mozRequestFullScreen) { /* Firefox */
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameContainer.mozRequestFullScreen().catch(err => console.error('Moz fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (gameContainer.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameContainer.webkitRequestFullscreen().catch(err => console.error('Webkit fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (gameContainer.msRequestFullscreen) { /* IE/Edge */
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameContainer.msRequestFullscreen().catch(err => console.error('MS fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn('Fullscreen API not supported by this browser.');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log('Attempting to exit fullscreen');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (document.exitFullscreen) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.exitFullscreen().catch(err => console.error('Exit fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (document.mozCancelFullScreen) { /* Firefox */
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.mozCancelFullScreen().catch(err => console.error('Moz exit fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.webkitExitFullscreen().catch(err => console.error('Webkit exit fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (document.msExitFullscreen) { /* IE/Edge */
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  document.msExitFullscreen().catch(err => console.error('MS exit fullscreen failed:', err));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn('Exit Fullscreen API not supported by this browser.');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error('Error during fullscreen toggle:', err);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Initial Setup ---
Â  Â  Â  Â  window.addEventListener('resize', resizeCanvas);
window.addEventListener('load', () => {
Â  Â  loadRemoteLeaderboard(); // Load leaderboard from the server on page load
Â  Â  resizeCanvas();
Â  Â  showNameInputScreen();
});

Â  Â  </script>
</body>
</html>
